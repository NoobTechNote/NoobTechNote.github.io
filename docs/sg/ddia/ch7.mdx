---
title: "Ch7: 交易"
sidebar_label: "Ch7: 交易"
sidebar_position: 7
---

## ACID

交易所提供的安全保證
一組能夠精確描述資料庫容錯機制的術語

Atomicity: 原子性
Consistency: 一致性
Isolation: 隔離性
Durability: 持久性

實際上不同資料庫的ACID實作並不完全相同，隔離性的含義有很多含糊之處，
當一個系統宣稱他是 "ACID相容" 的時候，
你實際上無法確切知道他到提供了什麼樣的保證，
ACID基本上已經變成一種行銷術語了

不符合ACID標諄的系統有時稱為BASE

Basically Available: 基本可用
Soft State: 軟狀態
Eventual consistency: 最終一致性

這些比ACID的定義更模糊，幾乎可以代表任何你想要的東西

### Atomicity 原子性

ACID的原子性描述了，当客户想进行多次写入，但在一些写操作处理完之后出现故障的情 况。例如进程崩溃，网络连接中断，磁盘变满或者某种完整性约束被违反。如果这些写操作 被分组到一个原子事务中，并且该事务由于错误而不能完成(提交)，则该事务将被中止， 并且数据库必须丢弃或撤消该事务中迄今为止所做的任何写入。
定义特征是:能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。 或许 可中止性(abortability) 是更好的术语，但本书将继续使用原子性，因为这是惯 用词。

all-or-nothing

### Consistency 一致性

ACID一致性的概念是，对数据的一组特定陈述必须始终成立。即不变量(invariants)。例 如，在会计系统中，所有账户整体上必须借贷相抵
一些特定类型的不变量可以由数据库检查，例如外键约束或唯一约束，但是一般来说，是应用程序来定义什么样的数据是有效的，什么样是无效的。—— 数据 库只管存储。
应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此， 字母C不属于ACID。

### Isolation 隔離性

大多数数据库都会同时被多个客户端访问。如果它们各自读写数据库的不同部分，这是没有 问题的，但是如果它们访问相同的数据库记录，则可能会遇到并发问题(竞争条件(race conditions))。
ACID意义上的隔离性意味着，同时执行的事务是相互隔离的:它们不能相互冒犯。

![](./ch7/fig7_1.png)

### Durability 持久性

数据库系统的目的是，提供一个安全的地方存储数据，而不用担心丢失。持久性是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。
在单节点数据库中，持久性通常意味着数据已被写入非易失性存储设备，如硬盘或SSD。它通常还包括预写日志或类似的文件(参阅“让B树更可靠”)，以便在磁盘上的数据结构损坏时 进行恢复
在带复制的数据库中，持久性可能意味着数据已成功复制到一些节点。为了提供 持久性保证，数据库必须等到这些写入或复制完成后，才能报告事务成功提交。

完美的持久性是不存在的 :如果所有硬盘和所有备份同时被销毁，那 显然没有任何数据库能救得了你。

在历史上，持久性意味着写入归档磁带。后来它被理解为写入硬盘或SSD。最近它已经
适应了“复制(replication)”的新内涵。哪种实现更好一些? 真相是，没有什么是完美的:
在实践中，没有一种技术可以提供绝对保证。只有各种降低风险的技术，包括写入磁盘，
复制到远程机器和备份——它们可以且应该一起使用。与往常一样，最好抱着怀疑 的态度接受任何理论上的“保证”

## 單物件和多物件操作

假设你想同时修改多个对象(行，文档，记录)。通常需要多对象事务(multi- object transaction) 来保持多块数据同步。图7-2展示了一个来自电邮应用的例子。
每当一个新消息写入时，必须也增长未读计数器，每当一个消息被标记为已读时，也必须减少未读计数器。

![](./ch7/fig7_2.png)
![](./ch7/fig7_3.png)

在关系型数据库中，通常基 于客户端与数据库服务器的TCP连接:在任何特定连接上， BEGIN TRANSACTION 和 COMMIT 语句之间的所有内容，被认为是同一事务的一部分
另一方面，许多非关系数据库并没有将这些操作组合在一起的方法。即使存在多对象API(例 如，键值存储可能具有在一个操作中更新几个键的多重放置操作)，但这并不一定意味着它 具有事务语义:该命令可能在一些键上成功，在其他的键上失败，使数据库处于部分更新的 状态。

### 單物件寫入

当单个对象发生改变时，原子性和隔离也是适用的。例如，假设您正在向数据库写入一个 20
KB的 JSON文档:
如果在发送第一个10 KB之后网络连接中断，数据库是否存储了不可解析的10KB JSON 片段?
如果在数据库正在覆盖磁盘上的前一个值的过程中电源发生故障，是否最终将新旧值拼接在一起?
如果另一个客户端在写入过程中读取该文档，是否会看到部分更新的值?

原子性可以通过使用日志来实现崩溃恢复(参阅“使B树可 靠”)，并且可以使用每个对象上的锁来实现隔离(每次只允许一个线程访问对象)

一些数据库也提供更复杂的原子操作，例如自增操作，这样就不再需要像图7-1那样的读取-修改-写入序列了。


```
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

同样流行的是比较和设置(CAS, compare-and-set) 操作，当值没有并发被其他人修改过时，才允许执行写操作。

```
-- 根据数据库的实现情况，这可能也可能不安全
UPDATE wiki_pages SET content = '新内容'
 WHERE id = 1234 AND content = '旧内容';
```

这些单对象操作很有用，因为它们可以防止在多个客户端尝试同时写入同一个对象时丢失更新(参阅“防止丢失更新”)。
但它们不是通常意义上的事务。CAS以及其他单一对象操作被称为“轻量级事务”
事务通常被理解为，将多个对象上的多个操作合并为一个执行单元的机制。

### 多物件交易的必要性

许多分布式数据存储已经放弃了多对象事务，因为多对象事务很难跨分区实现，而且在需要 高可用性或高性能的情况下，它们可能会碍事。
但说到底，在分布式数据库中实现事务，并 没有什么根本性的障碍。第9章 将讨论分布式事务的实现。

我们是否需要多对象事务?是否有可能只用键值数据模型和单对象操作来实现任何应用程序?

有一些场景中，单对象插入，更新和删除是足够的。但是许多其他场景需要协调写入几个不
同的对象:
在关系数据模型中，一个表中的行通常具有对另一个表中的行的外键引用。 (类似的 是，在一个图数据模型中，一个顶点有着到其他顶点的边)。多对象事务使你确信这些引用始终有效:当插入几个相互引用的记录时，外键必须是正确的，最新的，不然数据就没有意义。
在文档数据模型中，需要一起更新的字段通常在同一个文档中，这被视为单个对象——更新单个文档时不需要多对象事务。但是，缺乏连接功能的文档数据库会鼓励非规范化 (参阅“关系型数据库与文档数据库在今日的对比”)。当需要更新非规范化的信息时，如图7-2 所示，需要一次更新多个文档。事务在这种情况下非常有用，可以防止非规范化的数据不同步。
在具有二级索引的数据库中(除了纯粹的键值存储以外几乎都有)，每次更改值时都需 要更新索引。从事务角度来看，这些索引是不同的数据库对象:例如，如果没有事务隔离性，记录可能出现在一个索引中，但没有出现在另一个索引中，因为第二个索引的更新还没有发生。

这些应用仍然可以在没有事务的情况下实现。然而，没有原子性，错误处理就要复杂得多，
缺乏隔离性，就会导致并发问题。我们将在“弱隔离级别”中讨论这些问题，并在第12章中探讨 其他方法。

### 處理錯誤和中止

事务的一个关键特性是，如果发生错误，它可以中止并安全地重试，中止的重点就是允许安全的重试。
ACID数据库基于这样的 哲学:如果数据库有违反其原子性，隔离性或持久性的危险，则宁愿完全放弃事务，而不是留下半成品。
然而并不是所有的系统都遵循这个哲学。特别是具有无主复制的数据存储，主要是在“尽力而 为”的基础上进行工作

尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美:
* 如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障(所 以客户端认为提交失败了)，那么重试事务会导致事务被执行两次——除非你有一个额外的应用级除重机制。
* 如果错误是由于负载过大造成的，则重试事务将使问题变得更糟，而不是更好。为了避 免这种正反馈循环，可以限制重试次数，使用指数退避算法，并单独处理与过载相关的错误(如果允许)。
* 仅在临时性错误(例如，由于死锁，异常情况，临时性网络中断和故障切换)后才值得 重试。在发生永久性错误(例如，违反约束)之后重试是毫无意义的。
* 如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用。例如， 如果你正在发送电子邮件，那你肯定不希望每次重试事务时都重新发送电子邮件。
* 如果你想确保几个不同的系统一起提交或放弃，二阶段提交(2PC, two-phase commit) 可以提供帮助(“原子提交和两阶段提交(2PC)”中将讨论这个问题)。 
* 如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失。

## 弱隔離級別

### 讀已提交

#### 無髒讀

#### 無髒寫

#### 讀已提交的實作

### 快照隔離和可重複讀取

#### 快照隔離的實作

#### 觀察一致性快照的可見性規則

#### 索引和快照隔離

#### 可重複讀取和命名混淆

### 防止更新丟失

### 寫入偏斜和幻讀

