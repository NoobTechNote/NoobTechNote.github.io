---
title: "Ch5: 分散式資料系統"
sidebar_label: "Ch5: 分散式資料系統"
sidebar_position: 1
---

# 第二部分: 分散式資料系統

第一部分是儲存資料的時所應該考慮的各種面向，第二部分討論：如果資料儲存和檢索涉及到多台機器，會怎麼樣？

考慮使用多台機器的時機:
- Scalability
- Fault tolerance/High availability
- Latency

### Scaling to Higher Load

#### Scaling up vs. Scaling out
- Scaling up 又被稱為 vertical scaling
    - Share memory 限制: 很貴，容錯不好，就算提供熱插拔的 disk, memory，地理上也一定會有限制
    - Share disk 限制: race condition 時會有 lock 開銷

- shared-nothing architecture，又被稱為 horizontal scaling 或稱為 scaling out
    - 執行資料庫軟體的每臺機器 / 虛擬機器都稱為 節點（node）。每個節點只使用各自的處理器，記憶體和磁碟。節點之間的任何協調，都是在軟體層面使用傳統網路實現的。
    - 第二部分主要都在討論無共享架構所會產生的問題以及權衡

### Replication vs. Partition
資料分佈在多個節點上有兩種常見的方式：

- Replication

在幾個不同的節點上儲存資料的相同副本，可能放在不同的位置。Replication 提供了冗餘：如果一些節點不可用，剩餘的節點仍然可以提供資料服務。Replication 也有助於改善效能。第五章將討論 Replication。

- Partitioning

將一個大型資料庫拆分成較小的子集（稱為 分割槽，即 partitions），從而不同的分割槽可以指派給不同的 節點（nodes，亦稱 分片，即 sharding）。第六章將討論Partitioning。


複製和分割槽是不同的機制，但它們經常同時使用。如下圖所示。

一個 Database 切分為兩個 Partition，每個 Partition 都有兩個 Replication
![](./ch5/5-1-combine-partition-and-replication.png)

理解了這些概念，就可以開始討論在分散式系統中需要做出的困難抉擇。第七章 將討論 事務（Transaction），這對於瞭解資料系統中可能出現的各種問題，以及我們可以做些什麼很有幫助。第八章 和 第九章 將討論分散式系統的根本侷限性。



# Chapter 5 Replication
![](./ch5/5-2-ch5.jpg)

The major difference between a thing that might go wrong and a thing that cannot possibly
go wrong is that when a thing that cannot possibly go wrong goes wrong it usually turns out
to be impossible to get at or repair. —Douglas Adams, Mostly Harmless (1992)

Replication 意味著在透過網路連線的多臺機器上保留相同資料的副本
- To keep data geographically close to your users (and thus reduce latency)
- To allow the system to continue working even if some of its parts have failed (and thus increase availability)
- To scale out the number of machines that can serve read queries (and thus increase read throughput)


## Overview
- Single Leader replication
    - Sync vs. Async Replication
    - Leader / Follower failure handling
        - Follower failure: catch-up recovery
        - Lead failure: Failover
    - Replication log and its implementation
        - Statement-based replication
        - Write-ahead log(WAL) shipping
        - Logical (row-based) log replication
        - Trigger-based replication
    - Solution of Replication Lags
        - Reading Your Own Writes
        - Monotonic Reads
        - Consistent Prefix Reads
        - Solutions for Replication Lag

- Multi Leader replication
    - Client offline edit / collaborative editing
    - Conflict detection / avoidance / resolve
    - Conflict definition
    - Multi-leader topology


## Leader and Follower
![](./ch5/5-3-leader-based-replication.jpg)
這種複製模式是許多關係資料庫的內建功能，如 PostgreSQL（從 9.0 版本開始）、MySQL、Oracle Data Guard 和 SQL Server 的 AlwaysOn Availability Groups。它也被用於一些 Nonrelational DB，包括 MongoDB。最後，基於領導者的複製並不僅限於資料庫：像 Kafka和 RabbitMQ high available queues 這樣的分散式message brokers 也使用它。某些網路檔案系統，例如 DRBD 這樣的replicated block devices也與之類似。
## Sync vs. Async Replication
![](./ch5/5-4-sync-versus-async-follower.jpg)
**Special case:**
[Chain Replication](https://www.cs.cornell.edu/home/rvr/papers/OSDI04.pdf)
(used in Azure Storage and Amazon EBS)

## Setting Up New Followers
簡單地將資料檔案從一個節點複製到另一個節點通常是不夠的：因為客戶端會不斷向資料庫寫入資料

可以透過 Lock 資料庫來使磁碟上的檔案保持一致(像銀行系統) ，但是這會違背高可用的目標。

好險設定新 Follower 通常並不需要停機：

1. Take a consistent snapshot of the leader's database
2. Copy snapshot to follower
3. 從 follower 連線到 leader，並拉取快照之後發生的所有資料變更。這要求快照與leader replication log 中的位置精確關聯。PostgreSQL 將其稱為 log sequence number，MySQL 將其稱為 binlog coordinates。

當 follower 處理完快照之後積累的資料變更，我們就說它 caught up 了

建立follower的實際步驟因資料庫而異。有可能手動或自動或者一些神秘的工作流程

## Follower failure: Catch-up recovery
每個 Follower 在 disk 上記錄從 Leader 收到的資料變更。如果 Follower 壞掉重新啟動或斷網，則 Follower 可以從日誌中知道在發生故障之前處理的最後一個Transaction。之後 Follower 可以連線到 Leader，並請求在壞掉期間發生的所有資料變更。

## Leader failure: Failover
其中一個 Follower 要被 promote 為新的 Leader，需要重新配置客戶端，以將它們的寫操作傳送給新的 Leader，其他 Follower 需要開始拉取來自新 Leader 的資料變更。這個過程被稱為 failover

failover可以手動或自動。自動的failover步驟：

1. 確認 Leader 失效。有很多事情可能會出錯：崩潰、停電、網路問題等等。沒有萬無一失的方法，所以大多數系統只是簡單使用Timeout
2. 選擇一個新的 Leader 。這可以透過選舉過程（ Leader 由剩餘 Follower 以多數選舉產生）來完成(需要共識演算法)。
3. 重新配置系統以啟用新的 Leader。客戶端現在需要將它們的寫請求傳送給新 Leader。如果舊 Leader 恢復，可能仍然認為自己是 Leader ，而沒有意識到其他副本已經讓它失去領導權了。系統需要確保舊 Leader 意識到新 Leader 的存在，併成為一個 Follower 。

故障切換的過程中有很多地方可能出錯：

- 新 Leader 沒有收到老 Leader 掛掉前最後的寫入操作。
- 如果資料庫需要和其他外部儲存相協調，那麼丟棄寫入內容是極其危險的操作。 Example: 例如在 GitHub 的一場事故中，一個過時的 MySQL Follower 被提升為Leader。資料庫使用自增 ID 作為Primary，因為新主庫的計數器落後於老主庫的計數器，所以新主庫重新分配了一些已經被老主庫分配掉的 ID 作為主鍵。這些主鍵也在 Redis 中使用，主鍵重用使得 MySQL 和 Redis 中的資料產生不一致，最後導致一些私有資料洩漏到錯誤的使用者手中。
- Split brain
- 如何知道 Leader 是真的掛掉了，如果只是Spike，反而會加重負擔

## Implementation of Replication Logs
### :thumbsdown: Statement-based replication
複製每個 statement 到 follower 執行，像 SQL statement，但是很多情況會導致 replication 壞掉
1. nondeterministic function, such as NOW() or RAND() is likely to generate a different value on each replica.
2. If statements depend on the existing data in the database (e.g., UPDATE ... WHERE ...),  must be executed in exactly the same order on each replica
3. side effects (e.g., triggers, stored procedures, user-defined functions)

### :thumbsdown: Write-ahead log (WAL) shipping
usually every write to a database is appended to a log
- In SSTables and LSM-Trees, WAL is the main place for storage. Log segments are compacted in the background.
- In B-tree, every modification is first written to a WAL so that the index can be restored to a consistent state after a crash.

好處：WAL 包含了所有資料庫寫入的append-only sequence of bytes。可以使用完全相同的日誌在另一個節點上構建一模一樣的 replica

缺點：非常底層，無法看懂，跟storage engine耦合，換版本或換storage engine可能會有downtime

### :thumbsup: Logical (row-based) log replication
不綁定storage engine，可以只儲存作replication所需要的必要資訊
logical log  is usually at the granularity of a row:
- For an inserted row, the log contains the new values of all columns.
- For a deleted row, the log contains enough information to uniquely identify the
row that was deleted. Typically this would be the primary key, but if there is no
primary key on the table, the old values of all columns need to be logged.
- For an updated row, the log contains enough information to uniquely identify
the updated row, and the new values of all columns (or at least the new values of
all columns that changed).

Ref:
- https://www.postgresql.org/docs/current/logical-replication.html
- https://dev.mysql.com/doc/refman/8.0/en/replication.html

### :neutral_face: Trigger-based replication

客製化工具，只需複製自己指定範圍的資料，或者在自己想要的時間trigger


For Example:
- [Oracle GoldenGate](https://www.oracle.com/integration/goldengate/)
- Store procedure
- triggers


![](./ch5/5-5-write-but-read-nothing.jpg)
![](./ch5/5-6-time-go-backward.jpg)
![](./ch5/5-7-multi-leader.jpg)
![](./ch5/5-8-write-conflict.jpg)
![](./ch5/5-9-topology.jpg)
![](./ch5/5-10-wrong-order-arrive.jpg)

