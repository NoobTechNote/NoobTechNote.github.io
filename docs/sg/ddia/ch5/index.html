<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-sg/ddia/ch5">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Ch5: 分散式資料系統 | Noob Tech Note</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://noobtechnote.github.io/docs/sg/ddia/ch5"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Ch5: 分散式資料系統 | Noob Tech Note"><meta data-rh="true" name="description" content="第一部分是儲存資料的時所應該考慮的各種面向，第二部分討論：如果資料儲存和檢索涉及到多台機器，會怎麼樣？"><meta data-rh="true" property="og:description" content="第一部分是儲存資料的時所應該考慮的各種面向，第二部分討論：如果資料儲存和檢索涉及到多台機器，會怎麼樣？"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://noobtechnote.github.io/docs/sg/ddia/ch5"><link data-rh="true" rel="alternate" href="https://noobtechnote.github.io/docs/sg/ddia/ch5" hreflang="en"><link data-rh="true" rel="alternate" href="https://noobtechnote.github.io/docs/sg/ddia/ch5" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.40771ce4.css">
<link rel="preload" href="/assets/js/runtime~main.a8df846d.js" as="script">
<link rel="preload" href="/assets/js/main.92f7933b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/icon-144.png" alt="Noob Tech Note" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/icon-144.png" alt="Noob Tech Note" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Noob Tech Note</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/sg">Study Group</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/sg/">Study Group Notes</a><button aria-label="Toggle the collapsible sidebar category &#x27;Study Group Notes&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/clean-architecture/">Clean Architecture</a><button aria-label="Toggle the collapsible sidebar category &#x27;Clean Architecture&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/sg/ddia/ch1">資料密集型應用系統設計</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/ddia/ch1">Ch1: 可靠、可擴展與可維護的系統</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/ddia/ch3">Ch3: 儲存與索引</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/ddia/ch4">Ch4: 資料編碼與演化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/sg/ddia/ch5">Ch5: 分散式資料系統</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/ddia/ch5-leaderless">Ch5: 複製:無主複製</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/fenix-architecture/">鳳凰架構</a><button aria-label="Toggle the collapsible sidebar category &#x27;鳳凰架構&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/five-lines-of-code/">五行程式碼規則</a><button aria-label="Toggle the collapsible sidebar category &#x27;五行程式碼規則&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/fundamentals-of-software-architecture/">軟體架構原理 - 工程方法</a><button aria-label="Toggle the collapsible sidebar category &#x27;軟體架構原理 - 工程方法&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/web-api-the-good-parts/">Web API: The Good Parts</a><button aria-label="Toggle the collapsible sidebar category &#x27;Web API: The Good Parts&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/sg/"><span itemprop="name">Study Group Notes</span></a><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">資料密集型應用系統設計</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Ch5: 分散式資料系統</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>第二部分: 分散式資料系統</h1><p>第一部分是儲存資料的時所應該考慮的各種面向，第二部分討論：如果資料儲存和檢索涉及到多台機器，會怎麼樣？</p><p>考慮使用多台機器的時機:</p><ul><li>Scalability</li><li>Fault tolerance/High availability</li><li>Latency</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="scaling-to-higher-load">Scaling to Higher Load<a href="#scaling-to-higher-load" class="hash-link" aria-label="Direct link to Scaling to Higher Load" title="Direct link to Scaling to Higher Load">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="scaling-up-vs-scaling-out">Scaling up vs. Scaling out<a href="#scaling-up-vs-scaling-out" class="hash-link" aria-label="Direct link to Scaling up vs. Scaling out" title="Direct link to Scaling up vs. Scaling out">​</a></h4><ul><li><p>Scaling up 又被稱為 vertical scaling</p><ul><li>Share memory 限制: 很貴，容錯不好，就算提供熱插拔的 disk, memory，地理上也一定會有限制</li><li>Share disk 限制: race condition 時會有 lock 開銷</li></ul></li><li><p>shared-nothing architecture，又被稱為 horizontal scaling 或稱為 scaling out</p><ul><li>執行資料庫軟體的每臺機器 / 虛擬機器都稱為 節點（node）。每個節點只使用各自的處理器，記憶體和磁碟。節點之間的任何協調，都是在軟體層面使用傳統網路實現的。</li><li>第二部分主要都在討論無共享架構所會產生的問題以及權衡</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="replication-vs-partition">Replication vs. Partition<a href="#replication-vs-partition" class="hash-link" aria-label="Direct link to Replication vs. Partition" title="Direct link to Replication vs. Partition">​</a></h3><p>資料分佈在多個節點上有兩種常見的方式：</p><ul><li>Replication</li></ul><p>在幾個不同的節點上儲存資料的相同副本，可能放在不同的位置。Replication 提供了冗餘：如果一些節點不可用，剩餘的節點仍然可以提供資料服務。Replication 也有助於改善效能。第五章將討論 Replication。</p><ul><li>Partitioning</li></ul><p>將一個大型資料庫拆分成較小的子集（稱為 分割槽，即 partitions），從而不同的分割槽可以指派給不同的 節點（nodes，亦稱 分片，即 sharding）。第六章將討論Partitioning。</p><p>複製和分割槽是不同的機制，但它們經常同時使用。如下圖所示。</p><p>一個 Database 切分為兩個 Partition，每個 Partition 都有兩個 Replication
<img loading="lazy" src="/assets/images/5-1-combine-partition-and-replication-8c142d49bc23362230859996328fb9cd.png" width="1122" height="636" class="img_ev3q"></p><p>理解了這些概念，就可以開始討論在分散式系統中需要做出的困難抉擇。第七章 將討論 事務（Transaction），這對於瞭解資料系統中可能出現的各種問題，以及我們可以做些什麼很有幫助。第八章 和 第九章 將討論分散式系統的根本侷限性。</p><h1>Chapter 5 Replication</h1><p><img loading="lazy" src="/assets/images/5-2-ch5-7a9232a9b9fe741836c5f7b212f02e9c.jpg" width="660" height="816" class="img_ev3q"></p><p>The major difference between a thing that might go wrong and a thing that cannot possibly
go wrong is that when a thing that cannot possibly go wrong goes wrong it usually turns out
to be impossible to get at or repair. —Douglas Adams, Mostly Harmless (1992)</p><p>Replication 意味著在透過網路連線的多臺機器上保留相同資料的副本</p><ul><li>To keep data geographically close to your users (and thus reduce latency)</li><li>To allow the system to continue working even if some of its parts have failed (and thus increase availability)</li><li>To scale out the number of machines that can serve read queries (and thus increase read throughput)</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="overview">Overview<a href="#overview" class="hash-link" aria-label="Direct link to Overview" title="Direct link to Overview">​</a></h2><ul><li><p>Single Leader replication</p><ul><li>Sync vs. Async Replication</li><li>Leader / Follower failure handling<ul><li>Follower failure: catch-up recovery</li><li>Lead failure: Failover</li></ul></li><li>Replication log and its implementation<ul><li>Statement-based replication</li><li>Write-ahead log(WAL) shipping</li><li>Logical (row-based) log replication</li><li>Trigger-based replication</li></ul></li><li>Replication Lag Problems and Solution<ul><li>Reading Your Own Writes</li><li>Monotonic Reads</li><li>Consistent Prefix Reads</li><li>Solutions for Replication Lag</li></ul></li></ul></li><li><p>Multi Leader replication</p><ul><li>Client offline edit / collaborative editing</li><li>Conflict detection / avoidance / resolve</li><li>Conflict definition</li><li>Multi-leader topology</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="leader-and-follower">Leader and Follower<a href="#leader-and-follower" class="hash-link" aria-label="Direct link to Leader and Follower" title="Direct link to Leader and Follower">​</a></h2><p><img loading="lazy" src="/assets/images/5-3-leader-based-replication-4dfc89caadd89f8be2800015eccba2e1.jpg" width="1116" height="434" class="img_ev3q">
這種複製模式是許多關係資料庫的內建功能，如 PostgreSQL（從 9.0 版本開始）、MySQL、Oracle Data Guard 和 SQL Server 的 AlwaysOn Availability Groups。它也被用於一些 Nonrelational DB，包括 MongoDB。最後，基於領導者的複製並不僅限於資料庫：像 Kafka和 RabbitMQ high available queues 這樣的分散式message brokers 也使用它。某些網路檔案系統，例如 DRBD 這樣的replicated block devices也與之類似。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sync-vs-async-replication">Sync vs. Async Replication<a href="#sync-vs-async-replication" class="hash-link" aria-label="Direct link to Sync vs. Async Replication" title="Direct link to Sync vs. Async Replication">​</a></h3><p><img loading="lazy" src="/assets/images/5-4-sync-versus-async-follower-2cc0f2137c4981f53cbc92a8a449e2b5.jpg" width="1122" height="552" class="img_ev3q">
<strong>Special case:</strong>
<a href="https://www.cs.cornell.edu/home/rvr/papers/OSDI04.pdf" target="_blank" rel="noopener noreferrer">Chain Replication</a>
(used in Azure Storage and Amazon EBS)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="setting-up-new-followers">Setting Up New Followers<a href="#setting-up-new-followers" class="hash-link" aria-label="Direct link to Setting Up New Followers" title="Direct link to Setting Up New Followers">​</a></h3><p>簡單地將資料檔案從一個節點複製到另一個節點通常是不夠的：因為客戶端會不斷向資料庫寫入資料</p><p>可以透過 Lock 資料庫來使磁碟上的檔案保持一致(像銀行系統) ，但是這會違背高可用的目標。</p><p>好險設定新 Follower 通常並不需要停機：</p><ol><li>Take a consistent snapshot of the leader&#x27;s database</li><li>Copy snapshot to follower</li><li>從 follower 連線到 leader，並拉取快照之後發生的所有資料變更。這要求快照與leader replication log 中的位置精確關聯。PostgreSQL 將其稱為 log sequence number，MySQL 將其稱為 binlog coordinates。</li></ol><p>當 follower 處理完快照之後積累的資料變更，我們就說它 caught up 了</p><p>建立follower的實際步驟因資料庫而異。有可能手動或自動或者一些神秘的工作流程</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="follower-failure-catch-up-recovery">Follower failure: Catch-up recovery<a href="#follower-failure-catch-up-recovery" class="hash-link" aria-label="Direct link to Follower failure: Catch-up recovery" title="Direct link to Follower failure: Catch-up recovery">​</a></h3><p>每個 Follower 在 disk 上記錄從 Leader 收到的資料變更。如果 Follower 壞掉重新啟動或斷網，則 Follower 可以從日誌中知道在發生故障之前處理的最後一個Transaction。之後 Follower 可以連線到 Leader，並請求在壞掉期間發生的所有資料變更。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="leader-failure-failover">Leader failure: Failover<a href="#leader-failure-failover" class="hash-link" aria-label="Direct link to Leader failure: Failover" title="Direct link to Leader failure: Failover">​</a></h3><p>其中一個 Follower 要被 promote 為新的 Leader，需要重新配置客戶端，以將它們的寫操作傳送給新的 Leader，其他 Follower 需要開始拉取來自新 Leader 的資料變更。這個過程被稱為 failover</p><p>failover可以手動或自動。自動的failover步驟：</p><ol><li>確認 Leader 失效。有很多事情可能會出錯：崩潰、停電、網路問題等等。沒有萬無一失的方法，所以大多數系統只是簡單使用Timeout</li><li>選擇一個新的 Leader 。這可以透過選舉過程（ Leader 由剩餘 Follower 以多數選舉產生）來完成(需要共識演算法)。</li><li>重新配置系統以啟用新的 Leader。客戶端現在需要將它們的寫請求傳送給新 Leader。如果舊 Leader 恢復，可能仍然認為自己是 Leader ，而沒有意識到其他副本已經讓它失去領導權了。系統需要確保舊 Leader 意識到新 Leader 的存在，併成為一個 Follower 。</li></ol><p>故障切換的過程中有很多地方可能出錯：</p><ul><li>新 Leader 沒有收到老 Leader 掛掉前最後的寫入操作。</li><li>如果資料庫需要和其他外部儲存相協調，那麼丟棄寫入內容是極其危險的操作。 Example: 例如在 GitHub 的一場事故中，一個過時的 MySQL Follower 被提升為Leader。資料庫使用自增 ID 作為Primary，因為新主庫的計數器落後於老主庫的計數器，所以新主庫重新分配了一些已經被老主庫分配掉的 ID 作為主鍵。這些主鍵也在 Redis 中使用，主鍵重用使得 MySQL 和 Redis 中的資料產生不一致，最後導致一些私有資料洩漏到錯誤的使用者手中。</li><li>Split brain</li><li>如何知道 Leader 是真的掛掉了，如果只是Spike，反而會加重負擔</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="implementation-of-replication-logs">Implementation of Replication Logs<a href="#implementation-of-replication-logs" class="hash-link" aria-label="Direct link to Implementation of Replication Logs" title="Direct link to Implementation of Replication Logs">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="-statement-based-replication">👎 Statement-based replication<a href="#-statement-based-replication" class="hash-link" aria-label="Direct link to 👎 Statement-based replication" title="Direct link to 👎 Statement-based replication">​</a></h4><p>複製每個 statement 到 follower 執行，像 SQL statement，但是很多情況會導致 replication 壞掉</p><ol><li>nondeterministic function, such as NOW() or RAND() is likely to generate a different value on each replica.</li><li>If statements depend on the existing data in the database (e.g., UPDATE ... WHERE ...),  must be executed in exactly the same order on each replica</li><li>side effects (e.g., triggers, stored procedures, user-defined functions)</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="-write-ahead-log-wal-shipping">👎 Write-ahead log (WAL) shipping<a href="#-write-ahead-log-wal-shipping" class="hash-link" aria-label="Direct link to 👎 Write-ahead log (WAL) shipping" title="Direct link to 👎 Write-ahead log (WAL) shipping">​</a></h4><p>usually every write to a database is appended to a log</p><ul><li>In SSTables and LSM-Trees, WAL is the main place for storage. Log segments are compacted in the background.</li><li>In B-tree, every modification is first written to a WAL so that the index can be restored to a consistent state after a crash.</li></ul><p>好處：WAL 包含了所有資料庫寫入的append-only sequence of bytes。可以使用完全相同的日誌在另一個節點上構建一模一樣的 replica</p><p>缺點：非常底層，無法看懂，跟storage engine耦合，換版本或換storage engine可能會有downtime</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="-logical-row-based-log-replication">👍 Logical (row-based) log replication<a href="#-logical-row-based-log-replication" class="hash-link" aria-label="Direct link to 👍 Logical (row-based) log replication" title="Direct link to 👍 Logical (row-based) log replication">​</a></h4><p>不綁定storage engine，可以只儲存作replication所需要的必要資訊，也適合發給外部系統作客製化索引或data warehouse
logical log  is usually at the granularity of a row:</p><ul><li>For an inserted row, the log contains the new values of all columns.</li><li>For a deleted row, the log contains enough information to uniquely identify the
row that was deleted. Typically this would be the primary key, but if there is no
primary key on the table, the old values of all columns need to be logged.</li><li>For an updated row, the log contains enough information to uniquely identify
the updated row, and the new values of all columns (or at least the new values of
all columns that changed).</li></ul><p>Ref:</p><ul><li><a href="https://www.postgresql.org/docs/current/logical-replication.html" target="_blank" rel="noopener noreferrer">https://www.postgresql.org/docs/current/logical-replication.html</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/replication.html" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/doc/refman/8.0/en/replication.html</a></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="-trigger-based-replication">😐 Trigger-based replication<a href="#-trigger-based-replication" class="hash-link" aria-label="Direct link to 😐 Trigger-based replication" title="Direct link to 😐 Trigger-based replication">​</a></h3><p>客製化工具，只需複製自己指定範圍的資料，或者在自己想要的時間trigger</p><p>For Example:</p><ul><li><a href="https://www.oracle.com/integration/goldengate/" target="_blank" rel="noopener noreferrer">Oracle GoldenGate</a></li><li>Store procedure</li><li>triggers</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="problems-with-replication-lag">Problems with Replication Lag<a href="#problems-with-replication-lag" class="hash-link" aria-label="Direct link to Problems with Replication Lag" title="Direct link to Problems with Replication Lag">​</a></h2><p>Leader-based replication 適合用在多讀少寫的情況，可以分散讀取的工作負載，但就會遇到必須使用Async Replication所產生的Lag問題</p><p>Term: Eventual consistency</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="read-your-own-writes">Read Your Own Writes<a href="#read-your-own-writes" class="hash-link" aria-label="Direct link to Read Your Own Writes" title="Direct link to Read Your Own Writes">​</a></h3><p><img loading="lazy" src="/assets/images/5-5-write-but-read-nothing-33c88ccb0b133045f329a9822b1314f9.jpg" width="1114" height="542" class="img_ev3q"></p><p>Read-your-writes (Read-after-write) consistency: 當使用者重新載入頁面，重新整理時，確保一定看到自己剛剛提交的更新，但不保證看到其他使用者的最新更新</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="solutions">Solutions:<a href="#solutions" class="hash-link" aria-label="Direct link to Solutions:" title="Direct link to Solutions:">​</a></h4><ul><li>如果是讀自己寫的東西，從 leader 讀，否則從 follower 讀. e.g., twitter, teams</li><li>可以根據物件的last updated time，然後再參考 follower latency，來決定幾分鐘以內更新的資料去 leader 讀取，</li><li>紀錄使用者最後一次執行寫入的時間，如果follower不夠新，就去找其他可能比較新的follower，但這很依靠時間同步</li><li>如果Replica在不同的data center 會增加複雜性</li></ul><p>如果是跨裝置，像電腦跟手機要確保能即時看到另一邊的update，這種的 read-your-writes consistency就有更多要考慮的地方</p><ul><li>紀錄使用者timestamp不可行，因為裝置不同</li><li>網路不同，要確保這些device使用到同一個leader</li></ul><p><strong>Monotonic Read</strong>
<img loading="lazy" src="/assets/images/5-6-time-go-backward-4867763ad3407dac97f40605b12e16d3.jpg" width="1102" height="660" class="img_ev3q"></p><p>monotonic reads 可以保證這種異常不會發生。這是一個比 強一致性（strong consistency） 更弱，但比 最終一致性（eventual consistency） 更強的保證。當讀取資料時，你可能會看到一箇舊值；單調讀僅意味著如果一個使用者順序地進行多次讀取，則他們不會看到時間回退，也就是說，如果已經讀取到較新的資料，後續的讀取不會得到更舊的資料。</p><p>實現方法：每次同一個follower讀，可以用hash uid來指定follower</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="consistent-prefix-reads">Consistent Prefix Reads<a href="#consistent-prefix-reads" class="hash-link" aria-label="Direct link to Consistent Prefix Reads" title="Direct link to Consistent Prefix Reads">​</a></h3><p><img loading="lazy" src="/assets/images/5-7-see-the-future-1d14a50206dd7bedb1e3ba24f0054cff.jpg" width="1104" height="796" class="img_ev3q">
consistent prefix reads: This guarantee says that if a sequence of writes happens in a certain order,
then anyone reading those writes will see them appear in the same order.</p><p>一種解決方案是保證資料都寫到相同的partition，但可能沒有效率，後續有一些演算法論討論關於這種因果關係(causality)的問題</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="solutions-for-replication-lag">Solutions for Replication Lag<a href="#solutions-for-replication-lag" class="hash-link" aria-label="Direct link to Solutions for Replication Lag" title="Direct link to Solutions for Replication Lag">​</a></h3><p>在使用最終一致的系統時，如果複製延遲增加到幾分鐘甚至幾小時，則應該考慮應用程式的行為。如果答案是 “沒問題”，那很好。但如果結果對於使用者來說是不好的體驗，那麼設計系統來提供更強的保證是很重要的。明明是非同步複製卻假設複製是同步的，這是很多麻煩的根源。</p><p>但在應用程式程式碼中處理這些問題是複雜的，容易出錯。</p><p>如果應用程式開發人員不必擔心微妙的複製問題，並可以信賴他們的資料庫 “做了正確的事情”，那該多好呀。這就是 transaction 存在的原因：資料庫透過事務提供強大的保證，所以應用程式可以更加簡單。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="multi-leader-replication">Multi-Leader Replication<a href="#multi-leader-replication" class="hash-link" aria-label="Direct link to Multi-Leader Replication" title="Direct link to Multi-Leader Replication">​</a></h2><p>Leader-based replication has one major downside: there is only one leader, and all
writes must go through it.</p><p>Multi-leader allow more than one node to accept writes.</p><p>multi-leader (also known as master–master or active/active replication).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-cases-for-multi-leader-replication">Use Cases for Multi-Leader Replication<a href="#use-cases-for-multi-leader-replication" class="hash-link" aria-label="Direct link to Use Cases for Multi-Leader Replication" title="Direct link to Use Cases for Multi-Leader Replication">​</a></h3><p>在單個數據中心內部使用多個主庫的配置沒有太大意義，因為其導致的複雜性已經超過了能帶來的好處。但在一些情況下，這種配置也是合理的。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="multi-datacenter-operation">Multi-datacenter operation<a href="#multi-datacenter-operation" class="hash-link" aria-label="Direct link to Multi-datacenter operation" title="Direct link to Multi-datacenter operation">​</a></h4><p><img loading="lazy" src="/assets/images/5-8-multi-leader-52a90b584cbdb2766d087faeb81aa70a.jpg" width="1102" height="596" class="img_ev3q">
接下來比較多資料中心情況下，single-leader跟multi-leader的適應情況</p><ul><li>Performance</li></ul><table><thead><tr><th></th><th>Single-leader</th><th>Multi-leader</th></tr></thead><tbody><tr><td>Performance</td><td>每個寫入都要跨region寫入到Leader所在的datacenter，違反了使用多datacenter的目的</td><td>直接寫入到最近的datacenter，再replicate到其他datacenter</td></tr><tr><td>Tolerance of datacenter outages</td><td>Failover 把其他datacenter的follower提升成 Leader</td><td>其他datacenter leader正常執行，壞掉的datacenter後來再catch-up</td></tr><tr><td>Tolerance of network problems</td><td>跨Datacenter的網路通常要經過public internet會很不穩定</td><td>通常會比跨datacenter傳輸穩定</td></tr></tbody></table><p>各資料庫多使用外部工具來支援</p><ul><li>Tungsten Replicator for MySQL</li><li>BDR for PostgreSQL</li><li>GoldenGate for Oracle</li></ul><p>雖然multi-leader有很多好處，但有一個大缺點：相同資料可能在不同datacenters同時被修改，必須要解conflict
由於多主複製在許多資料庫中都屬於改裝的功能，所以常常存在微妙的配置缺陷，且經常與其他資料庫功能之間出現意外的反應。
比如</p><ul><li>autoincrementing keys</li><li>triggers</li><li>integrity constraint</li></ul><p>等都可能會有麻煩。因此，多主複製往往被認為是危險的領域，應儘可能避免</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="clients-with-offline-operation">Clients with offline operation<a href="#clients-with-offline-operation" class="hash-link" aria-label="Direct link to Clients with offline operation" title="Direct link to Clients with offline operation">​</a></h4><p>Example: Calendar, notion
每個device就像一個datacenter</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="collaborative-editing">Collaborative editing<a href="#collaborative-editing" class="hash-link" aria-label="Direct link to Collaborative editing" title="Direct link to Collaborative editing">​</a></h4><p>Example: Google doc, Wiki</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="handling-write-conflicts">Handling Write Conflicts<a href="#handling-write-conflicts" class="hash-link" aria-label="Direct link to Handling Write Conflicts" title="Direct link to Handling Write Conflicts">​</a></h3><p><img loading="lazy" src="/assets/images/5-9-write-conflict-2944fc788bb4e7790fce1d8fdcbcb699.jpg" width="1104" height="544" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="synchronous-versus-asynchronous-conflict-detection">Synchronous versus asynchronous conflict detection<a href="#synchronous-versus-asynchronous-conflict-detection" class="hash-link" aria-label="Direct link to Synchronous versus asynchronous conflict detection" title="Direct link to Synchronous versus asynchronous conflict detection">​</a></h4><p>基本上不可能用sync conflict detection，那你乾脆用single-leader</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="conflict-avoidance">Conflict avoidance<a href="#conflict-avoidance" class="hash-link" aria-label="Direct link to Conflict avoidance" title="Direct link to Conflict avoidance">​</a></h4><p>如果能保證某些特定寫入只會到同個Leader，這樣就沒有conflict了
舉例像某些客戶永遠只寫入特定的Leader，對單一個客戶來說，他只有single-leader
但客戶有可能會出國，這時候就有可能要換datacenter</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="converging-toward-a-consistent-state">Converging toward a consistent state<a href="#converging-toward-a-consistent-state" class="hash-link" aria-label="Direct link to Converging toward a consistent state" title="Direct link to Converging toward a consistent state">​</a></h4><p>讓conflict 收斂到一個值</p><ul><li>給每個write一個unique ID (e.g., timestamp, UUID, hash value)，值比較高的獲勝，如果使用timestamp，這種方法叫做 last write win (LWW)，雖然LWW很流行，但有可能會造成data loss</li><li>給每個replica一個ID, 高的贏，一樣有可能有data loss</li><li>把值merge或concat起來 (e.g., B/C)</li><li>通通寫進去，讀出來的時候讓user做選擇</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="custom-conflict-resolution-logic">Custom conflict resolution logic<a href="#custom-conflict-resolution-logic" class="hash-link" aria-label="Direct link to Custom conflict resolution logic" title="Direct link to Custom conflict resolution logic">​</a></h4><ul><li>On Write: 偵測到conflict，trigger conflict handler，讓用戶自己寫邏輯去解 (e.g., <a href="https://bucardo.org/Bucardo/operations/conflict_handling" target="_blank" rel="noopener noreferrer">Bucardo</a>)</li><li>On Read: all the conflicting writes are stored. When the data is read, app resolve the conflict, and write the result back to the database. CouchDB works this way.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="automatic-conflict-resolution">Automatic Conflict Resolution<a href="#automatic-conflict-resolution" class="hash-link" aria-label="Direct link to Automatic Conflict Resolution" title="Direct link to Automatic Conflict Resolution">​</a></h4><ul><li>Conflict-free replicated datatypes (CRDTs)<ul><li><a href="https://zh.wikipedia.org/zh-tw/%E6%97%A0%E5%86%B2%E7%AA%81%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/zh-tw/%E6%97%A0%E5%86%B2%E7%AA%81%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</a></li><li><a href="https://redis.io/active-active/" target="_blank" rel="noopener noreferrer">https://redis.io/active-active/</a></li></ul></li><li>Mergeable persistent data structures</li><li>Operational transformation<ul><li><a href="https://en.wikipedia.org/wiki/Operational_transformation" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Operational_transformation</a></li></ul></li></ul><p>什麼是conflict這件事會在Transaction那張深刻討論</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="multi-leader-replication-topologies">Multi-Leader Replication Topologies<a href="#multi-leader-replication-topologies" class="hash-link" aria-label="Direct link to Multi-Leader Replication Topologies" title="Direct link to Multi-Leader Replication Topologies">​</a></h3><p><img loading="lazy" src="/assets/images/5-10-topology-7a0187f0bcf726fd9e69c27e8dfd032a.jpg" width="1104" height="376" class="img_ev3q">
The most general topology is all-to-all.
MySQL by default supports only a circular topology
<img loading="lazy" src="/assets/images/5-11-wrong-order-arrive-26d40fb44b68434ec82e921c0ba6d4d3.jpg" width="1106" height="714" class="img_ev3q">
problem of causality</p><p>conflict detection techniques are poorly implemented in many multi-leader
replication systems. For example, PostgreSQL BDR does not
provide causal ordering of writes, and Tungsten Replicator for MySQL doesn’t
even try to detect conflicts <!-- -->[34]<!-- -->.</p><p>If you are using a system with multi-leader replication, it is worth being aware of
these issues, carefully reading the documentation, and thoroughly testing your database
to ensure that it really does provide the guarantees you believe it to have.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/NoobTechNote/NoobTechNote.github.io/tree/main/docs/sg/ddia/ch5.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2024-05-14T04:28:20.000Z">May 14, 2024</time></b> by <b>Mech</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/sg/ddia/ch4"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Ch4: 資料編碼與演化</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/sg/ddia/ch5-leaderless"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Ch5: 複製:無主複製</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#scaling-to-higher-load" class="table-of-contents__link toc-highlight">Scaling to Higher Load</a></li><li><a href="#replication-vs-partition" class="table-of-contents__link toc-highlight">Replication vs. Partition</a></li><li><a href="#overview" class="table-of-contents__link toc-highlight">Overview</a></li><li><a href="#leader-and-follower" class="table-of-contents__link toc-highlight">Leader and Follower</a><ul><li><a href="#sync-vs-async-replication" class="table-of-contents__link toc-highlight">Sync vs. Async Replication</a></li><li><a href="#setting-up-new-followers" class="table-of-contents__link toc-highlight">Setting Up New Followers</a></li><li><a href="#follower-failure-catch-up-recovery" class="table-of-contents__link toc-highlight">Follower failure: Catch-up recovery</a></li><li><a href="#leader-failure-failover" class="table-of-contents__link toc-highlight">Leader failure: Failover</a></li><li><a href="#implementation-of-replication-logs" class="table-of-contents__link toc-highlight">Implementation of Replication Logs</a></li><li><a href="#-trigger-based-replication" class="table-of-contents__link toc-highlight">😐 Trigger-based replication</a></li></ul></li><li><a href="#problems-with-replication-lag" class="table-of-contents__link toc-highlight">Problems with Replication Lag</a><ul><li><a href="#read-your-own-writes" class="table-of-contents__link toc-highlight">Read Your Own Writes</a></li><li><a href="#consistent-prefix-reads" class="table-of-contents__link toc-highlight">Consistent Prefix Reads</a></li><li><a href="#solutions-for-replication-lag" class="table-of-contents__link toc-highlight">Solutions for Replication Lag</a></li></ul></li><li><a href="#multi-leader-replication" class="table-of-contents__link toc-highlight">Multi-Leader Replication</a><ul><li><a href="#use-cases-for-multi-leader-replication" class="table-of-contents__link toc-highlight">Use Cases for Multi-Leader Replication</a></li><li><a href="#handling-write-conflicts" class="table-of-contents__link toc-highlight">Handling Write Conflicts</a></li><li><a href="#multi-leader-replication-topologies" class="table-of-contents__link toc-highlight">Multi-Leader Replication Topologies</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024. DEX Study Group</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a8df846d.js"></script>
<script src="/assets/js/main.92f7933b.js"></script>
</body>
</html>