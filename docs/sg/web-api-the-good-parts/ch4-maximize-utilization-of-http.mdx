---
title: "Ch4: 最大化的利用HTTP Protocol"
sidebar_label: "Ch4: 最大化的利用HTTP Protocol"
sidebar_position: 4
---

## 4.1 使用 HTTP 協議規範的意義

    - RFC (Request For Comments)

![http_request_message_format](./ch4/http_request_message_format.png)
![http_response_message_format](./ch4/http_response_message_format.png)

Image From:[The TCP/IP Guide](http://www.tcpipguide.com/free/t_HTTPGenericMessageFormat.htm)

## 4.2 正確使用狀態碼

### HTTP 狀態碼可區分為五大類：

- 1xx 消息
- 2xx 成功
- 3xx 重新導向
- 4xx 客戶端錯誤
- 5xx 伺服器錯誤

**主要的狀態碼**

| Status code | Nmae                   | Description                          |
| ----------- | ---------------------- | ------------------------------------ |
| 200         | OK                     | 請求成功                             |
| 201         | Created                | 請求已被接受，新的資源已創建         |
| 202         | Accepted               | 請求成功                             |
| 204         | No Content             | 沒有內容                             |
| 300         | Multiple Choices       | 返回多條重定向供選擇                 |
| 301         | Moved Permanently      | 永久重定向                           |
| 302         | Found                  | 臨时重定向                           |
| 303         | See Other              | 當前請求的資源在其它地址             |
| 304         | Not Modified           | 請求資源與本地緩存相同，未修改       |
| 307         | Temporary Redirect     | 臨時重定向，同 302                   |
| 400         | Bad Request            | 請求錯誤，通常是訪問的域名未綁定引起 |
| 401         | Unauthorized           | 需要身份认证验证                     |
| 403         | Forbidden              | 禁止訪問                             |
| 404         | Not Found              | 請求的內容未找到或已刪除             |
| 405         | Method Not Allowed     | 不允许的请求方法                     |
| 406         | Not Acceptable         | 無法響應，因資源無法滿足客戶端條件   |
| 408         | Request Timeout        | 請求超時                             |
| 409         | Conflict               | 存在衝突                             |
| 410         | Gone                   | 資源已經不存在(過去存在)             |
| 413         | Payload Too Large      | 請求的 URI 過長                      |
| 414         | Request-URI Too Long   | 請求資源與本地緩存相同，未修改       |
| 415         | Unsupported Media Type | 無法處理的媒體格式                   |
| 429         | Too Many Requests      | 並發請求過多                         |
| 500         | Internal Server Error  | 服務器端程序錯誤                     |
| 503         | Service Unavailable    | 服務器端臨時錯誤                     |

```
HTTP/1.1 200 OK
Content-Type: application/json

{
    "head": {
        "errorCode": 1001,
        "errorMessage": "Invalid parameter"
    },
    "body": {
        :
    }
}
```

## 4.3 Cache 與 HTTP

- 減少服務器的連線數量，可以提升用戶訪問速度
- 在網路連線斷開的狀態下也可以在某種程度提供服務
- 客戶端將資料暫存

:::info Discussion
反向代理服務器 Reverse Proxy
:::

### 4.3.1 過期模型(Expiration Model)
### 4.3.2 驗證模型(Validation Model)
### 4.3.3 啟發式過期(Heuristic Expiration)
### 4.3.4 不希望實施緩存的情況
### 4.3.5 使用Vary來指定緩存單位

## 4.4 Content-Type的指定

Content-Type是一個的HTTP Header，用來告訴對方自己所傳送的這包payload是什麼樣的類型

```
Content-Type: type/subtype [;options]

# Example
Content-Type: text/html; charset=utf-8
```

### 與Content-Type有關的情境

#### Request標明Server的處理方式

* AWS API Gateway對於不同的request Content-Type有一套預設的[處理方式](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-payload-encodings-workflow.html)

#### Response控制瀏覽器的行為

* Github用`text/plain`傳送的JS Source code內容，讓瀏覽器直接檢視source code而不會被意外執行
https://raw.githubusercontent.com/NoobTechNote/NoobTechNote.github.io/main/sidebars.js

如果在HTML內使用`<script>`Tag存取上面的js link，會得到錯誤

```
Refused to execute script from 'https://raw.githubusercontent.com/NoobTechNote/NoobTechNote.github.io/main/sidebars.js'
because its MIME type ('application/json') is not executable, and strict MIME type checking is enabled.
```

:::info Notice
一個常見的錯誤其實是使用text/html傳送javascript內容
所以你用的Backend Framework其實有在幫你處理Response的Content-Type

例如PHP的 [Symfony Response](https://github.com/symfony/symfony/blob/6.2/src/Symfony/Component/HttpFoundation/Response.php#L259)
:::

:::caution
瀏覽器其實不總是會聽Content-Type的意思，有時會依照內容猜測，該用什麼行為處理這個HTTP response

X-Content-Type-Options: nosniff 可以協助你阻止瀏覽器猜測response內容導致非預期的行為
:::

### Response的Content Type

#### 常見的Content-Type

| Content-Type           | 含義                                                                                                         |
| ---------------------- | ------------------------------------------------------------------------------------------------------------ |
| text/plain             | 純文字 [(註1)](#anchor1)                                                                                     |
| text/html              | HTML文件 [(註1)](#anchor1)                                                                                   |
| application/xml        | XML文件                                                                                                      |
| application/rss+xml    | RSS XML文件                                                                                                  |
| application/json       | JSON文件                                                                                                     |
| text/css               | CSS文件                                                                                                      |
| application/javascript | Javascript程式，舊稱text/javascript，但在[RFC4329](https://datatracker.ietf.org/doc/html/rfc4329#page-9)廢除 |
| multipart/form-data    | 表單資料，常用在Form POST Request                                                                            |
|                        |                                                                                                              |

<p id="anchor1">
    <strong>註1</strong>：
    語意上其實該屬於<code>application/</code>，但因為歷史因素維持<code>text/</code>分類
</p>

#### X- 開頭的Content Type

`x-`開頭的Content Type代表沒有在IANA註冊，通常具備特殊用途，或是自定義的Content Type會使用`x-`開頭去定義，例如

| Content Type          |                                             |
| --------------------- | ------------------------------------------- |
| application/x-msgpack | MessagePack                                 |
| application/x-yaml    | YAML文件                                    |
| application/x-plist   | Mac的property list，常見於下載iOS App的引導 |

但，因為歷史因素，有些`x-`開頭的Content Type是有在IANA註冊的

| Content Type             |                             |
| ------------------------ | --------------------------- |
| application/x-javascript | Javascript程式              |
| application/x-json       | JSON文件                    |
| image/x-png              | PNG圖片                     |
| x-www-form-urlencoded    | HTML Form [(註2)](#anchor2) |

<p id="anchor2">
    <strong>註2</strong>：用`x-www-form-urlencoded`傳送的資料，即使你用POST傳送，但實際上會被做URL Encode放在URL上。因為URL無法加密，如果帶有敏感訊息很容易會被各種log或中間人攔截
</p>

#### 自定義的Content Type

[RFC6838](https://datatracker.ietf.org/doc/html/rfc6838#section-3)有規定一組，如果你需要自己定義Content Type時的參考

* Standard Tree: 無前綴，標準中有定義的content-type，屬於被保留的一群
* Vendor Tree: `vnd`，有被IANA認證過的公司使用。通常會被大範圍使用，但由特定公司管理
    * application/vnd.ms-excel
    * application/vnd.github.v3+json
* Personal Tree: `prs.`，個人使用，或實驗性用途，只在非公開的狀況下被使用
    * appliccation/prs.mech.v1+json
* Unregistered Tree: `x.`，僅私有使用，不能被註冊

:::caution
注意`x.`跟`x-`是不同的，後者是有可能被註冊成標準的一部份
:::

:::info Discussion
你有用過非標準的Content Type嗎？好用嗎？Github為什麼這麼回應？

```
HTTP/1.1 200 OK
Server: Github.com
Content-Type: application/json; charset=utf-8
X-GitHub-Media-Type: github.v3
```
:::

### Request的Content Type

Accept: 我能夠吃怎樣的Response格式
Content-Type: 宣告目前傳送的payload是怎樣的格式

#### Accept Header

* `q`可以指定優先級，數字越大優先權越高，預設是最高`1`
* 所有回應格式都吃的話，使用`*/*`

翻譯：_我吃html, xhtml，但如果都沒有的話，也可以給我xml，再沒有可以給我webp，真的沒辦法就隨便吧_
```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9;image/webp,*/*;q=0.8
```


翻譯：_我吃json，但沒辦法的話xml也可以_

```
Accept: application/json,application/xml;q=0.9
```

#### Vary: Accept

在有API Gateway, Reversed Proxy存在請求端與伺服端的中間時，Accept Header有可能會被改變。

此時需要加上`Vary: Accept` Header要求Gateway轉交Accept Header或做進一步處理


## 4.5 Origin Policy與CORS資源共享

## 4.6 定義私有的HTTP Header

## 4.7 小結
