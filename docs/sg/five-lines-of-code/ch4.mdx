---
title: "Ch4: 讓型別碼能運作"
sidebar_label: "Ch4: 讓型別碼能運作"
sidebar_position: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## VCR

Ch3 的 Refactor 完的最後留下一連串的 if-else，讓 Ch4 來教你怎樣優雅的 Refactor 這些 if-else if-else 吧！

<Tabs>
<TabItem value="Before EXTRACT METHODE" default>

```typescript
function handleInputs() {
  while (inputs.length > 0) {
    let current = inputs.pop();
    if (current === Input.RIGHT) moveHorizontal(1);
    else if (current === Input.LEFT) moveHorizontal(-1);
    else if (current === Input.DOWN) moveVertical(1);
    else if (current === Input.UP) moveVertical(-1);
  }
}
```

</TabItem>
<TabItem value="After EXTRACT METHODE">

```typescript
function handleInputs() {
  while (inputs.length > 0) {
    let current = inputs.pop();
    handleInput(current);
  }
}
function handleInput(input: Input) {
  if (input === Input.RIGHT) moveHorizontal(1);
  else if (input === Input.LEFT) moveHorizontal(-1);
  else if (input === Input.DOWN) moveVertical(1);
  else if (input === Input.UP) moveVertical(-1);
}
```

</TabItem>
</Tabs>

## 4.1 重構一個簡單的 if 陳述句

在 EXTRACT METHODE 的規則中，我們只能留下一大串 else if，
但也無法再使用 EXTRACT METHODE 而且也不符合 FIVE LINES，那該怎麼辦呢？

> 那就不要用！

### 4.1.1 NEVER USE if WITH else

- 不要寫死決策
- 把第三方資料類型映射到自己的資料類型

```typescript
window.addEventListener("keydown", (e) => {
  if (e.key === LEFT_KEY || e.key === "a") inputs.push(Input.LEFT);
  else if (e.key === UP_KEY || e.key === "w") inputs.push(Input.UP);
  else if (e.key === RIGHT_KEY || e.key === "d") inputs.push(Input.RIGHT);
  else if (e.key === DOWN_KEY || e.key === "s") inputs.push(Input.DOWN);
});
```

#### 異味

早期綁定(early-binding)會阻止新增變更，只能透過修改 if 來進行變更。
後期綁定(late-binding)可以在執行程式最後才確定行為，比較理想。

#### 意圖

為了避免使用 if 來決定程式流程，盡量使用**物件**，使用物件可以根據實例化的類別來決定執行程式碼。

#### 參考

- 用類別替代型別碼 REPLACE TYPE CODE WITH CLASSES (4.1.3)
- 引入策略模式 INTRODUCE STRATEGY PATTERN (5.4.2)

### 4.1.2 套用規則

#### 使用 interface 來替換 enum

<Tabs>
<TabItem value="step 1" default>

```typescript
enum Input {
  RIGHT,
  LEFT,
  UP,
  DOWN,
}
interface Input2 {
  isRight(): boolean;
  isLeft(): boolean;
  isUp(): boolean;
  isDown(): boolean;
}
```

</TabItem>
<TabItem value="step 2" default>

```typescript
class Right implements Input2 {
 isRight() { return true; }
 isLeft() { return false; }
 isUp() { return false; }
 isDown() { return false; }
}
class Left implements Input2 { ... }
class Up implements Input2 { ... }
class Down implements Input2 { ... }
```

</TabItem>
<TabItem value="step 3" default>

```typescript title="Before"
function handleInput(input: Input) {
  if (input === Input.LEFT) moveHorizontal(-1);
  else if (input === Input.RIGHT) moveHorizontal(1);
  else if (input === Input.UP) moveVertical(-1);
  else if (input === Input.DOWN) moveVertical(1);
}
```

```typescript title="After"
function handleInput(input: Input2) {
  if (input.isLeft()) moveHorizontal(-1);
  else if (input.isRight()) moveHorizontal(1);
  else if (input.isUp()) moveVertical(-1);
  else if (input.isDown()) moveVertical(1);
}
```

</TabItem>
<TabItem value="step 4" default>

```typescript title="Before"
window.addEventListener("keydown", (e) => {
  if (e.key === LEFT_KEY || e.key === "a") inputs.push(Input.LEFT);
  else if (e.key === UP_KEY || e.key === "w") inputs.push(Input.UP);
  else if (e.key === RIGHT_KEY || e.key === "d") inputs.push(Input.RIGHT);
  else if (e.key === DOWN_KEY || e.key === "s") inputs.push(Input.DOWN);
});
```

```typescript title="After"
window.addEventListener("keydown", (e) => {
  if (e.key === LEFT_KEY || e.key === "a") inputs.push(new Left());
  else if (e.key === UP_KEY || e.key === "w") inputs.push(new Up());
  else if (e.key === RIGHT_KEY || e.key === "d") inputs.push(new Right());
  else if (e.key === DOWN_KEY || e.key === "s") inputs.push(new Down());
});
```

</TabItem>
<TabItem value="step 5" default>

```typescript title="Before"
window.addEventListener("keydown", (e) => {
  if (e.key === LEFT_KEY || e.key === "a") inputs.push(Input.LEFT);
  else if (e.key === UP_KEY || e.key === "w") inputs.push(Input.UP);
  else if (e.key === RIGHT_KEY || e.key === "d") inputs.push(Input.RIGHT);
  else if (e.key === DOWN_KEY || e.key === "s") inputs.push(Input.DOWN);
});
function handleInput(input: Input) {
  if (input === Input.LEFT) moveHorizontal(-1);
  else if (input === Input.RIGHT) moveHorizontal(1);
  else if (input === Input.UP) moveVertical(-1);
  else if (input === Input.DOWN) mmoveVertical(1);
}
```

```typescript title="After"
window.addEventListener("keydown", (e) => {
  if (e.key === LEFT_KEY || e.key === "a") inputs.push(new Left());
  else if (e.key === UP_KEY || e.key === "w") inputs.push(new Up());
  else if (e.key === RIGHT_KEY || e.key === "d") inputs.push(new Right());
  else if (e.key === DOWN_KEY || e.key === "s") inputs.push(new Down());
});
function handleInput(input: Input) {
  if (input.isLeft()) moveHorizontal(-1);
  else if (input.isRight()) moveHorizontal(1);
  else if (input.isUp()) moveVertical(-1);
  else if (input.isDown()) moveVertical(1);
}
```

</TabItem>
</Tabs>

### 4.1.3 REPLACE TYPE CODE WITH CLASSES

#### 描述

這個模式把 enum 轉換成 interface，把 enum 的值轉換成 class，這樣可以在每個值加入屬性，局部化該特定值得相關功能。
把 enum 轉換成 class 時，可以不需要考慮其他 enum 的值而把功能和資料結合在一起。
平常加入新的 enum 值，需要處理該 enum 所有地方的 if-else，或是 switch，而這個模式只需在 class 內實作新方法，不需要修改其他程式碼。

:::info
遇到需要檢查有關聯性的型別時 code，盡量都先轉換成 enum，再套用這個模式。

```typescript title="Before"
const SMALL = 33;
const MEDIUM = 37;
const LARGE = 42;
```

```typescript title="After"
enum TShirtSizes {
  SMALL = 33,
  MEDIUM = 37,
  LARGE = 42,
}
```

:::

#### 處理步驟

1. 請引入一個暫時的 interface，取個臨時的名字。這個介面應該要含有 enum 的每個值所對應的方法。
2. 建立與 enum 的每個值對應的類別，除了與該類別相對應的方法返回 true 之外，介面中的所有方法都應該返回 false。
3. 將 enum 重新命名。這樣會讓使用原本 enum 的所有地方回傳執錯誤訊息。
4. 把型别的舊名稱改成臨時名稱，並用新的方法替換相等性檢查。
5. 將剩下的參照到 enum 值的位置都替換為實例化新類別的處理方式。
6. 最後當不再回報錯誤時，把介面的名稱全都修改為永久使用的名稱。

#### 範例

<Tabs>
<TabItem value="Initial" default>

```typescript
enum TrafficLight {
  RED,
  YELLOW,
  GREEN,
}
const CYCLE = [TrafficLight.RED, TrafficLight.GREEN, TrafficLight.YELLOW];
function updateCarForLight(current: TrafficLight) {
  if (current === TrafficLight.RED) car.stop();
  else car.drive();
}
```

</TabItem >
<TabItem value="step 1" default>

```typescript
interface TrafficLight2 {
  isRed(): boolean;
  isYellow(): boolean;
  isGreen(): boolean;
}
```

</TabItem >
<TabItem value="step 2" default>

```typescript
class Red implements TrafficLight2 {
  isRed() {
    return true;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return false;
  }
}
class Yellow implements TrafficLight2 {
  isRed() {
    return false;
  }
  isYellow() {
    return true;
  }
  isGreen() {
    return false;
  }
}
class Green implements TrafficLight2 {
  isRed() {
    return false;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return true;
  }
}
```

</TabItem >
<TabItem value="step 3" default>

```typescript title="Before"
enum TrafficLight {
  RED,
  YELLOW,
  GREEN,
}
```

```typescript title="After"
enum RawTrafficLight {
  RED,
  YELLOW,
  GREEN,
}
```

</TabItem >
<TabItem value="step 4" default>

```typescript title="Before"
function updateCarForLight(current: TrafficLight) {
  if (current === TrafficLight.RED) car.stop();
  else car.drive();
}
```

```typescript title="After"
function updateCarForLight(current: TrafficLight2) {
  if (current.isRed()) car.stop();
  else car.drive();
}
```

</TabItem >
<TabItem value="step 5" default>

```typescript title="Before"
const CYCLE = [TrafficLight.RED, TrafficLight.GREEN, TrafficLight.YELLOW];
```

```typescript title="After"
const CYCLE = [new Red(), new Green(), new Yellow()];
```

</TabItem >
<TabItem value="step 6" default>

```typescript title="Before"
interface TrafficLight2 {
  // ...
}
```

```typescript title="After"
interface TrafficLight {
  // ...
}
```

</TabItem >
<TabItem value="Final" default>

```typescript title="Before"
interface TrafficLight {
  isRED(): boolean;
  isYELLOW(): boolean;
  isGREEN(): boolean;
}

class Red implements TrafficLight {
  isRed() {
    return true;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return false;
  }
}
class Yellow implements TrafficLight {
  isRed() {
    return false;
  }
  isYellow() {
    return true;
  }
  isGreen() {
    return false;
  }
}
class Green implements TrafficLight {
  isRed() {
    return false;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return true;
  }
}

const CYCLE = [new Red(), new Yellow(), new Green()];
function updateCarForLight(current: TrafficLight) {
  if (current.isRED()) car.stop();
  else car.drive();
}
```

</TabItem >
</Tabs>

這次的重構是為了為面的鋪陳，後面的章節會針對 isXXX()這類的 method 進行重構。

### 4.1.4 PUSHING CODE INTO CLASSES

<Tabs>
<TabItem value="Initial" default>

```typescript
interface Input {
  isRight(): boolean;
  isLeft(): boolean;
  isUp(): boolean;
  isDown(): boolean;
}

class Right implements Input {
 isRight() { return true; }
 isLeft() { return false; }
 isUp() { return false; }
 isDown() { return false; }
}
class Left implements Input { ... }
class Up implements Input { ... }
class Down implements Input { ... }

function handleInput(input: Input) {
  if (input.isLeft()) moveHorizontal(-1);
  else if (input.isRight()) moveHorizontal(1);
  else if (input.isUp()) moveVertical(-1);
  else if (input.isDown()) moveVertical(1);
}
```

</TabItem>
<TabItem value="step 1" default>

把 handleInput 放進 class 裡

```typescript
class Right implements Input {
 ...
 isRight() { return true; }
 isLeft() { return false; }
 isUp() { return false; }
 isDown() { return false; }

 handleInput(){
  if (this.isLeft()) moveHorizontal(-1);
  else if (this.isRight()) moveHorizontal(1);
  else if (this.isUp()) moveVertical(-1);
  else if (this.isDown()) moveVertical(1);
 }

}
class Left implements Input { ... }
class Up implements Input { ... }
class Down implements Input { ... }
```

</TabItem>
<TabItem value="step 2" default>

在 interface 裡加入 handleInput

```typescript title="Before"
interface Input {
  isRight(): boolean;
  isLeft(): boolean;
  isUp(): boolean;
  isDown(): boolean;
}
```

```typescript title="After"
interface Input {
  isRight(): boolean;
  isLeft(): boolean;
  isUp(): boolean;
  isDown(): boolean;

  handle(): void;
}
```

</TabItem>
<TabItem value="step 3" default>

此時如果 new Right()

```typescript

class Right implements Input {
 ...
 isRight() { return true; }
 isLeft() { return false; }
 isUp() { return false; }
 isDown() { return false; }

 handleInput(){
  if (false) moveHorizontal(-1);
  else if (true) moveHorizontal(1);
  else if (false) moveVertical(-1);
  else if (false) moveVertical(1);
 }

}

```

可以簡化成

```typescript

class Right implements Input {
 ...
 isRight() { return true; }
 isLeft() { return false; }
 isUp() { return false; }
 isDown() { return false; }

 handleInput(){
    moveHorizontal(1);
 }
}

```

因為是實作 interface 裡的 handle 所以可以廠 handleInput 改成 handle

```typescript
interface Input {
  isRight(): boolean;
  isLeft(): boolean;
  isUp(): boolean;
  isDown(): boolean;

  handle(): void;
}

class Right implements Input {
 ...
 isRight() { return true; }
 isLeft() { return false; }
 isUp() { return false; }
 isDown() { return false; }

 handle(){
    moveHorizontal(1);
 }
}

```

</TabItem>
<TabItem value="Final" default>

```typescript
interface Input {
  // ...
  handle(): void;
}
class Left implements Input {
  // ...
  handle() {
    moveHorizontal(-1);
  }
}
class Right implements Input {
  // ...
  handle() {
    moveHorizontal(1);
  }
}
class Up implements Input {
  // ...
  handle() {
    moveVertical(-1);
  }
}
class Down implements Input {
  // ...
  handle() {
    moveVertical(1);
  }
}
```

</TabItem>
</Tabs>

### 4.1.5 重構模式: PUSH CODE INTO CLASSES

#### 描述

- REPLACE TYPE CODE WITH CLASSES 的延伸
- 功能與資料會聚集到相應的 class
- 意在消除 if-else

#### 處理步驟

1. 把原本的 function 複製到複製到相關的 class 裡。把複製好的 function 字眼移除。把 if 內的方法更換成 this，
   因為使用 class 內的方法。
2. 把該 method 新增到該 class 實作的 interface 中，並取稍微不一樣的名字，方便提示修改。
3. 遍歷所有相關 class 中的新方法，移除多餘的 if-else
4. 把 class 內新增的方法改成 interface 內相應的方法，代表我們在 class 內完成了實作
5. 將原本 function 內的方法換成 interface 的方法

<Tabs>
<TabItem value="Initial" default>

```typescript
interface TrafficLight {
  isRed(): boolean;
  isYellow(): boolean;
  isGreen(): boolean;
}
class Red implements TrafficLight {
  isRed() {
    return true;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return false;
  }
}
class Yellow implements TrafficLight {
  isRed() {
    return false;
  }
  isYellow() {
    return true;
  }
  isGreen() {
    return false;
  }
}
class Green implements TrafficLight {
  isRed() {
    return false;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return true;
  }
}
function updateCarForLight(current: TrafficLight) {
  if (current.isRed()) car.stop();
  else car.drive();
}
```

</TabItem>
<TabItem value="step 1" default>

```typescript
interface TrafficLight {
  // ...
  updateCar(): void;
}
```

</TabItem>
<TabItem value="step 2" default>

```typescript
class Red implements TrafficLight {
  // ...
  updateCarForLight() {
    if (this.isRed()) car.stop();
    else car.drive();
  }
}
class Yellow implements TrafficLight {
  // ...
  updateCarForLight() {
    if (this.isRed()) car.stop();
    else car.drive();
  }
}
class Green implements TrafficLight {
  // ...
  updateCarForLight() {
    if (this.isRed()) car.stop();
    else car.drive();
  }
}
```

</TabItem>
<TabItem value="step 3" default>

  <Tabs>
  <TabItem value="Before" default>

```typescript
class Red implements TrafficLight {
  // ...
  updateCarForLight() {
    if (this.isRed()) car.stop();
    else car.drive();
  }
}
class Yellow implements TrafficLight {
  // ...
  updateCarForLight() {
    if (this.isRed()) car.stop();
    else car.drive();
  }
}
class Green implements TrafficLight {
  // ...
  updateCarForLight() {
    if (this.isRed()) car.stop();
    else car.drive();
  }
}
```

  </TabItem>
  <TabItem value="Because" default>

```typescript
class Red implements TrafficLight {
  // ...
  updateCarForLight() {
    if (true) car.stop();
    else car.drive();
  }
}
class Yellow implements TrafficLight {
  // ...
  updateCarForLight() {
    if (false) car.stop();
    else car.drive();
  }
}
class Green implements TrafficLight {
  // ...
  updateCarForLight() {
    if (false) car.stop();
    else car.drive();
  }
}
```

  </TabItem>
  <TabItem value="After" default>

```typescript
class Red implements TrafficLight {
  // ...
  updateCarForLight() {
    car.stop();
  }
}
class Yellow implements TrafficLight {
  // ...
  updateCarForLight() {
    car.drive();
  }
}
class Green implements TrafficLight {
  // ...
  updateCarForLight() {
    car.drive();
  }
}
```

  </TabItem>
  </Tabs>

</TabItem>
<TabItem value="step 4" default>
  <Tabs>
  <TabItem value="Before">

```typescript
class Red implements TrafficLight {
  // ...
  updateCarForLight() {
    car.stop();
  }
}
class Yellow implements TrafficLight {
  // ...
  updateCarForLight() {
    car.drive();
  }
}
class Green implements TrafficLight {
  // ...
  updateCarForLight() {
    car.drive();
  }
}
```

  </TabItem>
  <TabItem value="After">

```typescript
class Red implements TrafficLight {
  // ...
  updateCar() {
    car.stop();
  }
}
class Yellow implements TrafficLight {
  // ...
  updateCar() {
    car.drive();
  }
}
class Green implements TrafficLight {
  // ...
  updateCar() {
    car.drive();
  }
}
```

  </TabItem>
  </Tabs>
</TabItem>
<TabItem value="step 5" default>

  <Tabs>
  <TabItem value="Before" default>

```typescript
function updateCarForLight(current: TrafficLight) {
  if (current.isRed()) car.stop();
  else car.drive();
}
```

  </TabItem>
  <TabItem value="After" default>

```typescript
function updateCarForLight(current: TrafficLight) {
  current.updateCar();
}
```

  </TabItem>
  </Tabs>

</TabItem>
<TabItem value="Final" default>

```typescript
interface TrafficLight {
  isRed(): boolean;
  isYellow(): boolean;
  isGreen(): boolean;
  updateCar(): void;
}
class Red implements TrafficLight {
  isRed() {
    return true;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return false;
  }
  updateCar() {
    car.stop();
  }
}
class Yellow implements TrafficLight {
  isRed() {
    return false;
  }
  isYellow() {
    return true;
  }
  isGreen() {
    return false;
  }
  updateCar() {
    car.drive();
  }
}
class Green implements TrafficLight {
  isRed() {
    return false;
  }
  isYellow() {
    return false;
  }
  isGreen() {
    return true;
  }
  updateCar() {
    car.drive();
  }
}
function updateCarForLight(current: TrafficLight) {
  current.updateCar();
}
```

</TabItem>
</Tabs>

### 4.1.6 移除多餘的 function

<Tabs>
<TabItem value="Before" default>

```typescript
function handleInputs() {
  while (inputs.length > 0) {
    let current = inputs.pop();
    handleInput(current);
  }
}
function handleInput(input: Input) {
  input.handle();
}
```

</TabItem>
<TabItem value="After" default>

```typescript
function handleInputs() {
  while (inputs.length > 0) {
    let input = inputs.pop();
    input.handle();
  }
}
```

</TabItem>
</Tabs>

### 4.1.7 重構模式: INLINE METHOD

#### 描述

在上個範例中，我們使用重構方法 PUSH CODE INTO CLASSES 將 function 複製並新增到 class 裡面來進祥 refactor，
被複製剩下的 function 就是多餘的 function，這時候就可以使用 INLINE METHOD 來移除多餘的 function。

#### 處理步驟

1. 把 function 名稱暫時換掉，這時候會有錯誤訊息在所有使用該 function 的地方。
2. 複製這個 function 的內容，並留意他的參數。
3. 在錯誤訊息的地方把 function 內容貼上，並把參數對應到正確的位置。
4. 沒有錯誤訊息時，移除多餘的 function。

#### 範例

<Tabs>
<TabItem value="Initial" default>

```typescript
function deposit(to: string, amount: number) {
  let accountId = database.find(to);
  database.updateOne(accountId, { $inc: { balance: amount } });
}
function transfer(from: string, to: string, amount: number) {
  deposit(from, -amount);
  deposit(to, amount);
}
```

</TabItem>
<TabItem value="step 1" default>
<Tabs>
<TabItem value=" Befroe" default>

```typescript
function deposit(to: string, amount: number) {
  // ...
}
```

</TabItem>
<TabItem value=" After" default>

```typescript
function deposit2(to: string, amount: number) {
  // ...
}
```

</TabItem>
</Tabs>
</TabItem>
<TabItem value="step 2" default>
<Tabs>
<TabItem value="Before" default>

```typescript
function transfer(from: string, to: string, amount: number) {
  deposit(from, -amount);
  deposit(to, amount);
}
```

</TabItem>
<TabItem value="After" default>

```typescript
function transfer(from: string, to: string, amount: number) {
  let fromAccountId = database.find(from);
  database.updateOne(fromAccountId, { $inc: { balance: -amount } });
  let toAccountId = database.find(to);
  database.updateOne(toAccountId, { $inc: { balance: amount } });
}
```

</TabItem>
</Tabs>
</TabItem>
</Tabs>
