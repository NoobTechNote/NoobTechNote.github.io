---
title: 'Ch16: 向微服務邁進'
tsidebar_label: 'Ch16: 向微服務邁進'
sidebar_position: 16
---


## 沒有銀彈：軟體開發中任何一項技術、方法、架構都不可能是銀彈

* 本章：哪些場景適合去使用微服務，以及一些已經被驗證過、被總結為經驗的最佳的實踐方式，更主要是討論什麼場景不適合微服務，微服務存在哪些理解誤區。因為微服務也不是不是銀彈。

## 目的：微服務的驅動力
微服務的目的是有效的拆分應用，實現敏捷開發和部署。

> 為了應對日益龐大的壓力，獲得更好的性能，自然會演進至能夠擴縮自如的微服務架構。
> 能夠通過擴展硬體的手段解決問題就盡量別使用複雜的軟體方法，因為硬體的成本能夠持續穩定地下降，而軟體開發的成本則不可能。
> 而且，性能也不會因為採用了微服務架構而憑空產生。


通常比較常見的、合理的驅動力來自組織外部、內部兩方面

### 當意識到沒有什麼技術能夠包打天下
你不會一開始就想用 C 去寫 ML 的應用。
很多時候為異構能力進行的分佈式部署，並不是你想或者不想的問題，而是沒有選擇、無可避免的。

### 當個人能力因素成為系統發展的明顯制約
在單體架構下，沒有什麼有效阻斷錯誤傳播的手段，而微服務能夠物理劃分系統的**整體**與**部分**

### 當遇到來自外部商業層面對內部技術層面提出的要求
客戶說要 -> 微服務架構變成大型系統先進性的背書

### 變化發展特別快的創新業務系統往往會自主地向微服務架構靠近
避免程式碼在 library / package 的各種依賴而導致糾纏不清，讓系統有更好的可觀測性和自癒能力

### 大規模的、業務複雜的、歷史包袱沉重的系統也可能主動向微服務架構靠近
微服務在裡面扮演的角色是將**部分**系統拆除、修改、更新、替換



## 前提：微服務需要的條件 (= 什麼情況下可以開始微服務化)
解決非技術方面的問題，準確地說是人的問題

### 決策者與執行者都能意識到康威定律在軟件設計中的關鍵作用

:::info 康威定律
系統的架構趨同於組織的溝通結構。

為了推進軟件架構的微服務化而配合地調整組織架構，通常不是一件容易的事情。
因為架構不僅僅是個技術問題，更是一種社交活動，甚至還可能會涉及利益的重新分配。
這些問題不僅需要執行者有良好的社交能力，還需要更上層的決策者充分理解架構演變同步調整組織結構的必要性，為微服務化打破局部的利益藩籬。


### 組織中具備一些對微服務有充分理解、有一定實踐經驗的技術專家
微服務在架構方面帶來了額外的複雜性
開發 business logic 的 programer 可以不去深究跟踪治理、負載均衡、故障隔離、認證授權、伸縮擴展這些系統性的問題(?)，它們被掩埋在基礎設施之下
總使 Kubernetes、Istio、Spring Cloud、Dubbo 等現成的開源工具好用方便，但它們本身也具備不低的複雜性
所以我們需要可以在微服務架構中撐起系統主幹的技術專家和運維專家

未來的資訊技術行業
由於更先進的軟件架構已經允許更平庸的開發者也同樣能寫出可運行、可用於生產的軟件產品，同時又對精英開發者提出更多、更複雜的技術要求。


### 系統應具有以自治為目標的自動化與監控度量能力
《Microservice Prerequisites》Martin Fowler 2014
Rapid Provisioning：即使不依賴雲計算數據中心（中心化的單一節點）的支持，也有能力在短時間內迅速地啟動好一台新的服務器。
Basic Monitoring：監控**體系**有能力迅速捕捉到整體系統中出現的技術問題和業務問題。
Rapid Application Deployment：有能力通過全自動化的部署管道，將服務的變更迅速部署到測試或生產環境中。

:::info 部署管道 deployment pipeline
將 build 拆分成多個 stages, 而每個 stage 就可為這次的部署提供足夠的信心程度，遇到問題也能夠及時地知道錯誤發生地。
在實踐 CD 的過程中使用 deployment pipeline 可以更清楚的掌握系統的瓶頸、自動化機會和協作點

筆者認為微服務自動化的最終目的是構築一個可持續的生態系統，但並不是指要達到如此高的自動化程度之後才能開始微服務，只要滿足與系統規模和目標相匹配的自動化能力，建設微服務的不同時期，由不同程度的人力去參與運維完全是合情合理的。


### 複雜性已經成為製約生產力的主要矛盾
當單體架構與微服務架構的生產力曲線已經到達交叉點，此時開始進行微服務化才是有收益的。然而現實中很多架構師卻不得不在這上面**主動去犯錯**。
我們潛意識中總會希望系統建設是“少走幾步能到位”，不能真正地接受演進式設計。



## 邊界：微服務的粒度
識別微服務的邊界 => 領域趨動設計 Domain Driven Design(DDD)
:::info
Domain-Driven Design: Tackling Complexity in the Heart of Software https://www.tenlong.com.tw/products/9789864343874
Microservices Patterns: With examples in Java https://www.tenlong.com.tw/products/9787111624127

從業務之外的其他角度，從非功能性、研發效率

### 微服務粒度的下界是它至少應滿足獨立——能夠獨立發布、獨立部署、獨立運行與獨立測試，內聚——強相關的功能與數據在同一個服務中處理，完備——一個服務包含至少一項業務實體與對應的完整操作。
(X)微服務越小越好，反例如下
* 性能，服務粒度大小必須考慮到消耗在網絡上的時間與方法本身執行時間的比例，避免設計得的過於瑣碎，客戶端不得不多次調用服務才能完成一項業務操作。
* 一致性，如果某些數據必須要求保證強一致性的話，那它們本身就應當聚合在同一個微服務中，數據一致性是內聚。
* 可用性，微服務架構中應該把各種錯誤是為意料中。如果兩個微服務都必須依賴對方可用才能正常工作，那就應當將其合併到同一個微服務中。


### 微服務粒度的上界是一個2 Pizza Team 能夠在一個研發週期內完成的全部需求範圍。

#### 人數
微服務的上界並非受限於技術，而是受限於人，更準確地說，受限於人與人之間的社交協作。
>> 溝通成本= n×(n-1)/2 ，n 為參與項目的人數

#### 研發週期
人員數量固定的前提下，這個答案不僅與開發者的能力水平相關，更是與研發模式和周期相關。
* 瀑布開發
* Scrum
* Daily build



## 治理：理解系統複雜性

### 靜態的治理

複雜是相對於人而言的，是一個主觀標準，每個人都可以有不同的裁量。
複雜性的來源
* Cognitive Load：人接受業務、概念、模型、設計、接口、程式碼等信息所帶來的負擔大小，其中也包含技術的認知複雜度。系統中個體的認知負擔越大，系統就越複雜。
* Collaboration Cost(合作成本)：團隊共同研發時付出的溝通、管理成本高低。系統個體間協作的成本越高，系統就越複雜。

** 軟件規模小時微服務的複雜度高於單體系統，規模大時則相反。**這裡的原因就是微服務的認知負荷較高，但是協作成本較低。

### 發展的治理

Architectural Decay(架構腐化)：任何靜態的治理方案只能延緩，不能根治，必須在發展中才能尋找到徹底解決的辦法。
=> 演進式設計是治理架構腐化唯一有效的辦法

>> 演進式設計
>>
>> 正常工作的系統帶來了研發效率的下降
>> 程式碼復用性越高、可用性越低



:::info 破窗效應
任何一次違反架構設計，就像是在打破一扇窗戶，如果不及時修補，修復的成本會越來越高，而且會有越來越多的窗戶被打破。
最終導致系統難以維護，需要捨棄
:::


大型軟件的建設是一個不斷推倒重來的演進過程，前一個版本對後一個版本的價值在於它滿足了這個階段用戶的需要，讓團隊成功適應了這個階段的複雜度，可以向下一個台階邁進。
對於最終用戶來說，一個能在演進過程中逐步為用戶提供價值的系統，體驗也要遠好於一個憋大招的系統——哪怕這大招最終能成功憋。



我們無法避免架構腐化，卻完全有必要依靠良好的設計和治理，為項目的質量維持一段合理的“保質期”，讓它在合理的生命週期中發揮價值。

先進的生產力都伴隨著更高的複雜性，需要有與生產力符合的生產關係來匹配，敏銳地捕捉到生產力的變化，隨時調整生產關係，這才是架構師治理複雜性的終極方法。