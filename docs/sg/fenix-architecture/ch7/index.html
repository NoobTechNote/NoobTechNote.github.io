<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-sg/fenix-architecture/ch7">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Ch7: 從函式庫到服務 | Noob Tech Note</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://noobtechnote.github.io/docs/sg/fenix-architecture/ch7"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Ch7: 從函式庫到服務 | Noob Tech Note"><meta data-rh="true" name="description" content="微服務架構的重要設計原則之一是「通過服務實現獨立自治的組件」（Componentization via Services），強調應該使用「服務」（Service）而不是「函式庫」（Library）來構建組件化的程式。"><meta data-rh="true" property="og:description" content="微服務架構的重要設計原則之一是「通過服務實現獨立自治的組件」（Componentization via Services），強調應該使用「服務」（Service）而不是「函式庫」（Library）來構建組件化的程式。"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://noobtechnote.github.io/docs/sg/fenix-architecture/ch7"><link data-rh="true" rel="alternate" href="https://noobtechnote.github.io/docs/sg/fenix-architecture/ch7" hreflang="en"><link data-rh="true" rel="alternate" href="https://noobtechnote.github.io/docs/sg/fenix-architecture/ch7" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.7933f3c4.css">
<link rel="preload" href="/assets/js/runtime~main.d604e16f.js" as="script">
<link rel="preload" href="/assets/js/main.f1e20d8a.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/icon-144.png" alt="Noob Tech Note" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/icon-144.png" alt="Noob Tech Note" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Noob Tech Note</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/sg">Study Group</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/sg/">Study Group Notes</a><button aria-label="Toggle the collapsible sidebar category &#x27;Study Group Notes&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/clean-architecture/">Clean Architecture</a><button aria-label="Toggle the collapsible sidebar category &#x27;Clean Architecture&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/sg/fenix-architecture/">鳳凰架構</a><button aria-label="Toggle the collapsible sidebar category &#x27;鳳凰架構&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch0">Ch0: 前言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch1">Ch1: 服務架構演進史</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch2">Ch2: 存取遠端服務</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch3">Ch3: 交易處理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch4">Ch4: 透明多級分流系統</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch4.5-6">Ch4.5~6: 負載均衡和服務端緩存</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch5">Ch5: 架構安全性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch6">Ch6: 分佈式共識算法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/sg/fenix-architecture/ch7">Ch7: 從函式庫到服務</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch8">Ch8: 流量治理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch9">Ch9: 可靠通信</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch10">Ch10: 可觀測性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch11">Ch11: 虛擬化容器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch12">Ch12: 容器間網路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch13">Ch13: 持久化存储</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch14">Ch14: 資源與調度</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch15">Ch15: 服務網格</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sg/fenix-architecture/ch16">Ch16: 向微服務邁進</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/fundamentals-of-software-architecture/">軟體架構原理 - 工程方法</a><button aria-label="Toggle the collapsible sidebar category &#x27;軟體架構原理 - 工程方法&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/sg/web-api-the-good-parts/">Web API: The Good Parts</a><button aria-label="Toggle the collapsible sidebar category &#x27;Web API: The Good Parts&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/sg/"><span itemprop="name">Study Group Notes</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/sg/fenix-architecture/"><span itemprop="name">鳳凰架構</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Ch7: 從函式庫到服務</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Ch7: 從函式庫到服務</h1></header><p>微服務架構的重要設計原則之一是「通過服務實現獨立自治的組件」（Componentization via Services），強調應該使用「服務」（Service）而不是「函式庫」（Library）來構建組件化的程式。</p><ul><li>函式庫（Library）：在編譯期靜態連結到程式中，在本地使用方法來調用功能。</li><li>服務（Service）：進程外的組件，通過調用遠程方法來使用其中的功能。</li></ul><p>使用服務來構建程式，可實現軟體系統在物理層面上的「整體」與「部分」真正隔離。這對於構建可靠的大型軟體系統非常寶貴。</p><p>但是，微服務架構在複雜性和執行效能方面付出了極大的代價。</p><p>在一個由多個微服務相互調用才能正常運作的分佈式系統中，每個節點都互相扮演著服務的生產者和消費者的多重角色，形成了一個複雜的網狀調用關係。</p><p>此時，至少有以下三個問題需要考慮和解決：</p><ol><li>對消費者來說，外部的服務是由誰提供？在什麼網路位置上？</li><li>對生產者來說，哪些內部服務需要公開？哪些應該隱藏？應該以什麼形式公開服務？在集群中以什麼規則分配請求？</li><li>對調用過程來說，如何保證每個遠程服務都接收到相對平均的流量，以獲得最高的服務品質和可靠性？</li></ol><p>這三個問題的解決方案通常被稱為「服務發現」、「服務的網關路由」和「服務的負載均衡」。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="71-服務發現service-discovery">7.1 服務發現（Service Discovery）<a href="#71-服務發現service-discovery" class="hash-link" aria-label="Direct link to 7.1 服務發現（Service Discovery）" title="Direct link to 7.1 服務發現（Service Discovery）">​</a></h2><p>程式設計中常使用的函式庫封裝技術，讓電腦能夠透過不同模組之間的方法呼叫，組裝出可複用的指令序列，使得軟體開發的規模更為龐大。</p><p>不論是在編譯期間連結的 C、C++ 語言，還是在執行期間連結的 Java 語言，都需要透過連結器（Linker）將程式碼中的符號參照轉換為模組入口或程序內存地址的直接參照。</p><p>而隨著服務化的普及，軟體系統能夠透過分布於網路上不同的機器相互協作，以實現功能複用，這是軟體發展規模的第二次飛躍。</p><p>此時，如何確定目標方法的確切位置，便是與編譯連結同等重要的研究課題，解決這個問題的過程被稱為「服務發現」（Service Discovery）。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="711-服務發現的意義">7.1.1 服務發現的意義<a href="#711-服務發現的意義" class="hash-link" aria-label="Direct link to 7.1.1 服務發現的意義" title="Direct link to 7.1.1 服務發現的意義">​</a></h3><p>遠端服務調用通常使用全限定名（Fully Qualified Domain Name，FQDN）、端口號和服務標識三元組確定服務位置。</p><p>全限定名代表網路中主機的精確位置，端口代表主機上提供 TCP/UDP 網路服務的程序，服務標識代表程序提供的某個具體方法入口。</p><p>不同協議具有不同的標識形式，如：</p><ol><li>REST 使用 URL 地址</li><li>RMI 使用 Stub 類中的方法</li><li>SOAP 使用 WSDL 定義方法等。</li></ol><p>遠端服務標識的多樣性，使得服務發現有兩種理解：</p><ol><li>一種是「百科全書式」的服務發現，如 UDDI，包括企業信息、聯繫地址、分類目錄等，</li><li>另一種是類似於 DNS 的「門牌號碼式」服務發現，只需將代表服務提供者的全限定名轉換為服務實際主機 IP 地址，不關心服務廠家和方法細節。</li></ol><p>後一種服務發現是主流，服務坐標為「全限定名+端口號」。</p><p>本文的服務發現特指後一種。</p><p>原本服務發現僅依賴 DNS 將全限定名轉換為一至多個 IP 地址或其他類型的記錄。</p><p>負載平衡器也實際上承擔了一部分服務發現的職責。</p><p>然而，隨著微服務的流行，服務的宕機、重啟和上線、下線變得更加頻繁，僅靠 DNS 和負載平衡器等基礎設施已無法跟上服務變化的步伐。</p><p>人們嘗試使用 ZooKeeper 這樣的分布式 K/V 框架完成服務註冊與發現，但 ZooKeeper 是底層的分布式工具，用戶需要做更多工作才能滿足服務發現的需求。</p><p>2014 年，Netflix 內部經過長時間考驗的服務發現框架 Eureka 開源，很快成為 Spring 默認的遠程服務發現的解決方案。</p><p>到 2018 年，Consul 和 Nacos 成為 Spring Cloud Eureka 的替代品。</p><p>服務發現框架已經發展成熟，不僅支持 DNS 或 HTTP 請求進行符號與實際地址的轉換，還支持各種健康檢查方式、集中配置、K/V 存儲和跨數據中心數據交換等功能。</p><p>隨著雲原生時代的來臨，基礎設施的靈活性得到了增強，最初的使用基礎設施來透明化服務發現的方式又被人們所重視。</p><p>如何在基礎設施和網絡協議層面，對應用進行服務發現是當前服務發現的一個主要發展方向。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="712-可用與可靠availability-and-reliability">7.1.2 可用與可靠（Availability and Reliability）<a href="#712-可用與可靠availability-and-reliability" class="hash-link" aria-label="Direct link to 7.1.2 可用與可靠（Availability and Reliability）" title="Direct link to 7.1.2 可用與可靠（Availability and Reliability）">​</a></h3><p>服務發現具體包含三個過程：</p><ol><li>服務的註冊（Service Registration）：服務啟動時，透過某些形式（呼叫 API、產生 event message、寫入資料庫、在 ZooKeeper/Etcd 指定位置紀錄等），將服務的位置資訊（如 IP、端口、服務標識等）註冊到服務發現中心。</li><li>服務的維護（Service Maintaining）：服務發現中心須確保服務列表是健康的，透過各種手段（HTTP、TCP、長連接、心跳、探針、執行緒狀態等），監控服務是否健康存活，將不健康的服務自動從服務列表中剔除。</li><li>服務的發現（Service Discovery）：把服務的識別符號（FQDN 等）轉換成實際座標，通常透過 HTTP API 或 DNS Lookup 來完成。也有一些少用方式，例如 Kubernetes 支援注入環境變數來做服務發現。</li></ol><p>除了上述三個必備功能，服務發現框架可能還有其他選配功能，像是：</p><ol><li>負載平衡</li><li>流量管控</li><li>Key/Value 儲存</li><li>Meta Data 管理</li><li>業務分組等等</li></ol><p>後面章節會有專門介紹，這裡不展開。</p><p>接著我們來探討在分布式環境裡，服務發現框架遇到的 CAP 難題。</p><p>服務發現既要高可用，也要高可靠，這是因為服務發現在整個系統中的特殊地位。</p><p>典型的服務發現系統架構如下圖：</p><p><img loading="lazy" alt="Ideal Service Discovery System" src="/assets/images/7-1-idea-service-discovery-system-efcd15d77cfd44c1f6a414ee93f8125c.jpg" width="633" height="289" class="img_ev3q"></p><p>包含三種角色：</p><ol><li>服務發現中心（Service Discovery）</li><li>服務提供者（Service Provider）</li><li>服務消費者（Service Consumer）</li></ol><p>三者會進行以下操作：</p><ol><li>服務提供者在服務註冊中心註冊、續約、下線自己的真實座標</li><li>服務消費者根據某種符號從服務註冊中心獲取服務提供者的真實座標</li><li>服務消費者呼叫服務提供者</li></ol><p>三者在系統中相互關係是對等的。</p><p>但在真實世界，服務發現中心的地位是特殊的。它不依賴其他服務，但被所有其他服務共同依賴，是系統中最基礎的服務。</p><p>為了確保服務發現中心的可用性，通常我們會以集群的方式部署它，通常使用三或五個節點（通常不超過七個，否則資料複製成本太高）。</p><p>真實世界的系統架構通常如下：</p><p><img loading="lazy" alt="Real World Service Discovery System" src="/assets/images/7-2-realworld-service-discovery-system-cabe76d09ea20fb93aa90a1d28d55735.jpg" width="1155" height="490" class="img_ev3q"></p><p>我們要特別注意各服務發現中心之間的「Replicate」實踐。</p><p>我們希望服務發現中心永遠可用，而且能從任何節點拿到一致的資訊，避免發生拿回來的服務地址的服務其實已經下線的狀況。高可用和高一致性就構成了 CAP 矛盾，不可能同時滿足。</p><p>以兩個最具代表性的服務發現框架 Netflix Eureka 和 Hashicorp Consul 來說明：</p><ol><li>Eureka 的選擇是優先保證高可用性，相對犧牲系統中服務狀態的一致性。
Eureka 的各個節點間採用異步複製來交換服務註冊資訊，當有新服務註冊進來時，並不需要等待資訊在其他節點複製完成，而是馬上在該服務發現節點宣告服務可見，只是不保證在其他節點上多長時間後才會可見。
同時，當有舊的服務發生變動，譬如下線或者斷網，只會由超時機制來控制何時從哪一個服務註冊表中移除，變動資訊不會實時的同步給所有服務端與客戶端。
這樣的設計使得不論是 Eureka 的服務端還是客戶端，都能夠持有自己的服務註冊表快取，並以 TTL（Time to Live）機制來進行更新，哪怕服務註冊中心完全崩潰，客戶端在仍然可以維持最低限度的可用。
Eureka 的服務發現模型對節點關係相對固定，服務一般不會頻繁上下線的系統是很合適的，以較小的同步代價換取了最高的可用性；
Eureka 能夠選擇這種模型的底氣在於萬一客戶端拿到了已經發生變動的錯誤地址，也能夠通過 Ribbon 和 Hystrix 模組配合來兜底，實現故障轉移（Failover）或者快速失敗（Failfast）。</li><li>Consul 的選擇是優先保證高可靠性，相對犧牲系統服務發現的可用性。Consul 採用 Raft 算法，要求多數派節點寫入成功後服務的註冊或變動才算完成，嚴格地保證了在集群外部讀取到的服務發現結果必定是一致的；同時採用 Gossip 協議，支持多數據中心之間更大規模的服務同步。Consul 優先保證高可靠性一定程度上是基於產品現實情況而做的技術決策，它不像 Netflix OSS 那樣有著全家桶式的微服務組件，萬一從服務發現中取到錯誤地址，就沒有其他組件為它兜底了。</li></ol><p>Eureka 與 Consul 的差異帶來的影響主要不在於服務註冊的快慢（當然，快慢確實是有差別），而在於你如何看待以下這件事情：</p><p>假設系統形成了 A、B 兩個網絡分區後，A 區的服務只能從區域內的服務發現節點獲取到 A 區的服務坐標，B 區的服務只能取到在 B 區的服務坐標，這對你的系統會有什麼影響？</p><p>如果這件事情對你並沒有太大的影響，甚至有可能還是有益的，就應該傾向於選擇 AP 式的服務發現。譬如假設 A、B 就是不同的機房，是機房間的網絡交換機導致服務發現集群出現的分區問題，但每個分區中的服務仍然能獨立提供完整且正確的服務能力，此時儘管不是有意而為，但網絡分區在事實上避免了跨機房的服務請求，反而還帶來了服務調用鏈路優化的效果。</p><p>如果這件事情也可能對你影響非常之大，甚至可能帶來比整個系統宕機更壞的結果，就應該傾向於選擇 CP 式的服務發現。譬如係統中大量依賴了集中式緩存、消息總線、或者其他有狀態的服務，一旦這些服務全部或者部分被分隔到某一個分區中，會對整個系統的操作的正確性產生直接影響的話，那與其最後弄出一堆數據錯誤，還不如直接停機來得痛快。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="713-註冊中心實現">7.1.3 註冊中心實現<a href="#713-註冊中心實現" class="hash-link" aria-label="Direct link to 7.1.3 註冊中心實現" title="Direct link to 7.1.3 註冊中心實現">​</a></h3><p>在服務發現中，可用性和一致性是分布式系統永恆的矛盾，決策關注點是更能容忍服務列表不可用，還是服務數據不準確。</p><p>目前有三種服務發現方案：</p><ol><li>基於分布式 K/V 存儲框架的服務發現，例如 ZooKeeper、Doozerd、Etcd。</li><li>於基礎設施（主要是指 DNS 伺服器）的服務發現，例如 SkyDNS、CoreDNS。</li><li>專門用於服務發現的框架和工具，例如 Eureka、Consul 和 Nacos。</li></ol><p>這些方案各有利弊，應根據需求選擇。</p><p>譬如，使用 K/V 框架可保證 CP，但需自行實現許多基礎能力；基於基礎設施來做服務發現可以應用透明，但需自行解決一些問題；專門用於服務發現的框架和工具可以做到以聲明代替編碼，但需要考慮語言和框架的集成問題。</p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="72-閘道器與路由gateways-and-routers">7.2 閘道器與路由（Gateways and Routers）<a href="#72-閘道器與路由gateways-and-routers" class="hash-link" aria-label="Direct link to 7.2 閘道器與路由（Gateways and Routers）" title="Direct link to 7.2 閘道器與路由（Gateways and Routers）">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="721-閘道器的職責responsibilities-of-gateways">7.2.1 閘道器的職責（Responsibilities of Gateways）<a href="#721-閘道器的職責responsibilities-of-gateways" class="hash-link" aria-label="Direct link to 7.2.1 閘道器的職責（Responsibilities of Gateways）" title="Direct link to 7.2.1 閘道器的職責（Responsibilities of Gateways）">​</a></h3><p>在單體架構下，負載均衡器負責分發流量給各個系統副本，所以網關的角色並不太重要。</p><p>但在微服務架構下，每個服務節點都有自己獨立的接口，需要一個統一的代理人角色對外交互。因此，微服務中的網關變得越來越重要，甚至成為必不可少的設施之一。</p><p>微服務中的網關主要負責統一對外提供服務，將流量路由到內部集群中正確的服務節點，同時也可以作為流量過濾器，提供安全、認證、授權、限流、監控、緩存等功能。</p><p>因此，微服務中的網關包括「路由器」和「過濾器」兩個基礎職能。</p><p>服務網關需要考慮路由的協議層次和性能可用性，以便正確地路由流量。</p><p>在協議層次方面，服務網關與負載均衡器的技術實現沒有太大差別，但服務網關需要能夠識別流量中的特徵來進行正確路由。</p><p>此外，服務網關能夠支持的網絡通信協議的層次將直接影響後端服務節點的服務通信方式。</p><p>如果服務集群只提供基於 TCP 的訪問服務，只需要部署四層網關即可，而如果要提供 HTTP 服務，則必須部署七層網關，以便根據 HTTP 报文中的 URL、Header 等信息來路由流量。</p><p>服務網關的另一個重點是其性能和可用性，因為網關是所有服務對外的總出口，是流量必經之地，所以網關的路由性能將對系統產生系統性的影響。</p><p>網關的性能取決於其工作模式和自身實現算法，其中工作模式是最關鍵的因素。</p><p>採用 DSR 三角傳輸模式可以獲得更好的性能，但由於大多數服務接口都基於 HTTP 協議，所以服務網關通常只能採用代理模式來支持七層路由。</p><p>在這種情況下，網關的性能主要取決於它們如何代理網絡請求，即它們的網絡 I/O 模型。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="722-網路-io-模型network-io-models">7.2.2 網路 I/O 模型（Network I/O Models）<a href="#722-網路-io-模型network-io-models" class="hash-link" aria-label="Direct link to 7.2.2 網路 I/O 模型（Network I/O Models）" title="Direct link to 7.2.2 網路 I/O 模型（Network I/O Models）">​</a></h3><p>網路 I/O 就是對數據流的操作，包含以下兩階段：</p><ol><li>等待數據從遠端主機到達本機緩衝區</li><li>將資料從緩衝區複製到應用程式位址空間</li></ol><p>根據這兩階段的不同實作，網路 I/O 模型可以分為兩類、五種模型，我們以「領取便當」為例說明：</p><ol><li>一類：非同步 I/O（Asynchronous I/O）：訂外賣，付錢後就可以去做其他事，飯做完後外送員送到門口後會打電話通知你。資料到達緩衝區後，不需要由主程式主動複製資料，而是操作系統複製完後會通知主程式。</li><li>二類：同步 I/O（Synchronous I/O）：自己去餐廳裝飯，此時會有四種情境<ol><li>阻塞 I/O（Blocking I/O）：你到了餐廳，發現飯還沒煮好，你也無法做別的，只能打個盹（線程休眠），直到飯煮好，這就是被阻塞了。阻塞 I/O 是最直觀的 I/O 模型，邏輯清晰，也比較節省 CPU 資源，但缺點就是線程休眠所帶來的上下文切換，這是一種需要切換到內核狀態的重負載操作，不應當頻繁進行。</li><li>非阻塞 I/O（Non-Blocking I/O）：你到了餐廳，發現飯還沒煮好，你就回去了，然後每隔三分鐘去餐廳看飯煮好了沒，直到飯煮好。非阻塞 I/O 能夠避免線程休眠，對於一些很快就能返回結果的請求，非阻塞 I/O 可以節省切換上下文切換的消耗，但對於較長時間才能返回的請求，非阻塞 I/O 反而白白浪費了 CPU 資源，所以目前不常用。</li><li>多路復用 I/O（Multiplexing I/O）：多路復用 I/O 本質上是阻塞 I/O 的一種，但它的好處是可以在同一條阻塞線程上處理多個不同端口的監聽。比方說你叫雷鋒，代表整個宿舍去餐廳打飯，到了餐廳，發現飯還沒煮好，還是繼續打盹，但哪個室友的飯煮好了，你就立刻把那份飯送回去，然後繼續打盹等待其他的飯煮好。多路復用 I/O 是目前高並發網路應用的主流，它下面還可以細分 select、epoll、kqueue 等不同實現，這裡就不展開了。</li><li>信號驅動 I/O（Signal-Driven I/O）：你去到餐廳，發現飯還沒做好，但你跟廚師很熟，跟他說飯做好了叫你，然後回去該幹嘛幹嘛，等收到廚師通知後，你把飯從餐廳拿回宿舍。這裡廚師的通知就是那個「信號」，信號驅動 I/O 與非同步 I/O 的區別是「從緩衝區獲取數據」這個步驟的處理，前者收到的通知是可以開始進行複製操作了，即要你自己從餐廳拿回宿舍，在複製完成之前執行緒處於阻塞狀態，所以它仍屬於同步 I/O 操作，而後者收到的通知是複製操作已經完成，即外賣小哥已經把飯送到了。</li></ol></li></ol><p>總結來看，第一類的非同步 I/O（Asynchronous I/O）是最方便的。但它受限於作業系統的支援度。</p><p>Windows NT Kernel 3.5 就支援了非同步 I/O，而 Linux Kernel 2.6 後才首次導入，Linux 高併發網路應用主要還是使用多路復用 I/O（Multiplexing I/O）。</p><p>在分析網關的性能時，通常只能進行定性分析，要量化地比較哪種網關性能最好、快多少是很困難的。就像我們都認為 Chrome 比 IE 快，但具體情境下快多少就很難明確說明。</p><p>網關也存在可用性問題，因為每個系統的網路調用中都至少有一個單點存在。</p><p>對於小型系統來說，網關很容易成為網路訪問中的單點，因此它的可用性非常重要。</p><p>針對網關的可用性，我們應該注意以下幾點：</p><ol><li>網關應盡可能輕量，因為附加過多的功能會增加網關的負擔。</li><li>選擇網關時，應該盡可能选择经过长期考验的成熟產品，例如 Nginx Ingress Controller、KONG、Zuul 等，而不能一味追求最新產品的性能，需要在性能與可用性之間做出權衡。</li><li>在需要高可用的生產環境中，應該在網關之前部署負載均衡器或等價路由器（ECMP），讓更成熟的設施充當整個系統的入口地址，這樣可以增強網關的可擴展性。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="723-backends-for-frontends-閘道器backends-for-frontends-gateways">7.2.3 Backends for Frontends 閘道器（Backends for Frontends Gateways）<a href="#723-backends-for-frontends-閘道器backends-for-frontends-gateways" class="hash-link" aria-label="Direct link to 7.2.3 Backends for Frontends 閘道器（Backends for Frontends Gateways）" title="Direct link to 7.2.3 Backends for Frontends 閘道器（Backends for Frontends Gateways）">​</a></h3><p>BFF（Backends for Frontends）是隨著微服務一同興起的概念，旨在讓網關能夠針對不同的前端聚合不同的服務，提供不同的接口和協議支援。</p><p>舉例來說，對於運行於瀏覽器的 Web 程序，服務網關就應提供基於 HTTP 協議的 REST 服務；而對於運行於桌面系統的程序，可以部署另一套網關，提供基於更高性能協議（如 gRPC）的接口。</p><p>在網關這個邊緣節點上，針對同一後端集群，裁剪、適配、聚合出適應不同前端的服務，有助於後端的穩定性，也有助於前端的能力提升。</p><p><img loading="lazy" alt="Backend for Frontend" src="/assets/images/7-3-bff-d2b0b27a37b56d637e5eb4d15217407b.jpg" width="745" height="572" class="img_ev3q"></p><hr><h2 class="anchor anchorWithStickyNavbar_LWe7" id="73-客戶端負載平衡client-side-load-balancing">7.3 客戶端負載平衡（Client-side Load Balancing）<a href="#73-客戶端負載平衡client-side-load-balancing" class="hash-link" aria-label="Direct link to 7.3 客戶端負載平衡（Client-side Load Balancing）" title="Direct link to 7.3 客戶端負載平衡（Client-side Load Balancing）">​</a></h2><p>先區分幾個容易搞混的概念：服務發現、網關路由、負載平衡、和下一章節會介紹的服務容錯。</p><p>這裡個名詞都有著「從服務集群中找到一個適合的服務來呼叫」的意義。</p><p>以下面例子來說明他們的差異：</p><p>假設你在廣東，你在線上書店買書，程式邏輯中會呼叫這支 API 完成購買，請求如下：</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PATCH https://warehouse:8080/restful/stockpile/3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{amount: -1}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>再假設這線上書店很大，在世界各地機房都部署有服務集群。</p><p>整個請求的傳輸過程如下：</p><ol><li>服務發現：將 warehouse FQDN 轉換成服務的 ip，理想上會優先連接最接近發起端的機房，因此此處會變轉換成廣州 IP <code>guangzhou-ip-wan</code></li></ol><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PATCH https://guangzhou-ip-wan:8080/restful/stockpile/3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>網關路由：廣州機房的網關會根據請求的 URL 特徵，發現 URL 中的 <code>/restful/stockpile/**/restful/stockpile/**</code> 對應商品出貨服務，因此將請求的 IP 轉成內網 Warehouse 服務集群的入口地址：</li></ol><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PATCH https://warehouse-gz-lan:8080/restful/stockpile/3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="3"><li>負載平衡：集群內有多個 Warehouse 服務，負載平衡器根據某種標準決定要呼叫哪個子服務（隨機、輪詢、或呼叫次數最少的），假設這次選用 <code>warehouse-gz-lan-node1</code> 服務，請求會被改寫如下：</li></ol><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PATCH https://warehouse-gz-lan-node1:8080/restful/stockpile/3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="4"><li>如果 <code>warehouse-gz-lan-node1</code> 服務壞了，丟出 500 錯誤：</li></ol><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HTTP/1.1 500 Internal Server Error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="5"><li>服務容錯：根據預先設定的故障轉移策略，在其他節點重試請求，例如改呼叫 <code>warehouse-gz-lan-node2</code>，此時請求被改寫如下：</li></ol><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PATCH https://warehouse-gz-lan-node2:8080/restful/stockpile/3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="6"><li><code>warehouse-gz-lan-node2</code> 服務正常，請求成功：</li></ol><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HTTP/1.1 200 OK</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面 1、2、3、5，就對應了服務發現、網關路由、負載平衡、和服務容錯。</p><p>其中部分職責是有交叉的，例如步驟 1 服務發現，根據請求來源的物理位置分配機房，本質上是一種路由行為。</p><p>另外你是否覺得以上網路傳輸過程過於複雜？廣州機房內網的服務請求，在外網繞了一大圈，繞回機房內網另一個服務來回應，有方法能簡化嗎？</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="731-客戶端負載平衡器client-side-load-balancers">7.3.1 客戶端負載平衡器（Client-side Load Balancers）<a href="#731-客戶端負載平衡器client-side-load-balancers" class="hash-link" aria-label="Direct link to 7.3.1 客戶端負載平衡器（Client-side Load Balancers）" title="Direct link to 7.3.1 客戶端負載平衡器（Client-side Load Balancers）">​</a></h3><p>對於大型系統來說，負載平衡器是不可或缺的設備。</p><p>以前，負載平衡器主要部署在整個服務集群的前端，將用戶請求分配到各個服務進行處理。</p><p>隨著微服務的發展，服務集群不僅收到來自外部的請求，還有越來越多的訪問請求是由集群內部的服務發起的，因此，直接在服務集群內部消化內部流量變得更加合理。</p><p>這促使一種新的分散式負載平衡方式的出現：客戶端負載平衡器（Client-side Load Balancers）。</p><p><img loading="lazy" alt="Client-side Load Balancer" src="/assets/images/7-4-client-side-load-balancer-beede3be6acf8b0e9b2f46fb17b3a647.jpg" width="725" height="516" class="img_ev3q"></p><p>此時傳統的負載平衡器，我們可以給他另一個名字：服務端負載平衡器（Server-side Load Balancers）。</p><p>客戶端負載平衡器相較於服務器端負載平衡器相比，差異與優點如下：</p><ol><li>客戶端負載平衡器是和服務實例一一對應的，而且與服務實例共存於同一進程中。這意味著信息交換是進程內的方法調用，不存在額外的網絡開銷；</li><li>所有內部流量都僅在服務集群的內部循環，避免了流量繞場的尷尬局面；</li><li>天然避免了集中式的單點問題；</li><li>更加靈活，能夠為每個服務實例單獨設置平衡策略等參數，如具備親和性、隨機、輪詢、加權或最小連接等。</li></ol><p>但客戶端負載平衡器也有一些缺點：</p><ol><li>與服務運行於同一進程內，因此其選型受編程語言的限制。這個缺陷有違於微服務中技術異構不應受到限制的原則。</li><li>均衡器的穩定性會直接影響整個服務進程的穩定性，消耗的 CPU、內存等資源也同樣影響到服務的可用資源。</li><li>內部網絡安全和信任關係變得複雜，攻破任何一個服務可能會導致整個集群受到影響。</li><li>客戶端負載均衡器必須持續跟踪其他服務的健康狀況，以實現上線新服務、下線舊服務、自動剔除失敗的服務、自動重連恢復的服務等功能。這些操作需要通過訪問服務註冊中心來完成，數量龐大的客戶端負載均衡器持續輪詢服務註冊中心也會給它帶來不小的負擔。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="732-代理負載均衡器proxy-load-balancers">7.3.2 代理負載均衡器（Proxy Load Balancers）<a href="#732-代理負載均衡器proxy-load-balancers" class="hash-link" aria-label="Direct link to 7.3.2 代理負載均衡器（Proxy Load Balancers）" title="Direct link to 7.3.2 代理負載均衡器（Proxy Load Balancers）">​</a></h3><p>為解決這些問題，代理負載均衡器（Proxy Load Balancers）出現了。</p><p>代理均衡器改進了客戶端負載平衡器，將原本嵌入服務進程中的負載平衡器提取出來，作為一個特殊服務，放到邊緣代理中實現，這個代理服務與服務實例在同一 Pod 內，放到 Sidecar 裡實現。</p><p>流量關係如下：</p><p><img loading="lazy" alt="Proxy Client-side Load Balancer" src="/assets/images/7-5-proxy-client-side-load-balancer-cae2a4f6b336dfb1ca3b7f3f9a920011.jpg" width="843" height="514" class="img_ev3q"></p><p>客戶端負載平衡器與服務本身是 process 內通訊，而代理負載平衡器與服務本身是網絡通訊，數據要經過打包拆包、計算校驗和、維護序列號等步驟。</p><p>然而，Kubernetes 保證同一個 Pod 中的容器不會跨越不同的節點，這些容器共享同一個網絡名稱空間，所以代理均衡器與服務實例的交互實際上是對本機回環設備的訪問，所以它們比客戶端負載均衡器在性能上更高效且穩定。</p><p>代理負載均衡器（Proxy Load Balancers）的优点如下：</p><ol><li>不再受編程語言的限制，可以發展一個支持多種編程語言的通用的代理均衡器，</li><li>避免了客戶端均衡器的穩定性影響到服務進程的穩定等問題。</li><li>在服務拓撲感知方面代理均衡器也要更有優勢。由於邊車代理接受控制平面的統一管理，當服務節點拓撲關係發生變化時，控制平面就會主動向邊車代理髮送更新服務清單的控制指令，這避免了此前客戶端均衡器必須長期主動輪詢服務註冊中心所造成的浪費。</li><li>在安全性、可觀測性上，由於邊車代理都是一致的實現，有利於在服務間建立雙向 TLS 通信，也有利於對整個調用鏈路給出更詳細的統計信息。</li></ol><p>總之，通過同一個 Pod 的獨立容器實現的代理均衡器是目前最理想的處理微服務集群內部流量的方式，儘管服務網格本身還不夠成熟，對操作系統、網絡和運維方面的知識要求較高，但相信隨著時間的推移，未來這將會成為微服務的主流通信方式。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="733-地域與區域regions-and-zones">7.3.3 地域與區域（Regions and Zones）<a href="#733-地域與區域regions-and-zones" class="hash-link" aria-label="Direct link to 7.3.3 地域與區域（Regions and Zones）" title="Direct link to 7.3.3 地域與區域（Regions and Zones）">​</a></h3><p>最後再談一個與負載平衡器相關的話題，地域與區域（Regions and Zones）。在微服務或雲端常見。</p><ol><li>Region 地域：例如華北、東北、華東、華南等。全球或全國規模的大型系統服務集群通常會在多個地理區域部署，如本篇所舉的案例。大型系統通過在不同的地理區域的機房部署來縮短用戶與服務器之間的物理距離，以提高響應速度。小型系統通常只在異地容災時才需要考慮地理區域。需要注意的是，不同地理區域之間沒有內網連接，所有流量都必須通過公共互聯網相連。如果微服務流量跨越不同地理區域，就和調用外部服務提供商的互聯網服務沒有什麼區別。因此，集群內部的流量不會跨越地理區域，服務發現和負載均衡器默認也不支持跨地理區域的服務發現和負載均衡。</li><li>Zone 區域：它是「可用區域(Availability Zones)」的縮寫。區域是指在地理上位於同一地區內，但是電力和網絡是互相獨立的物理區域。例如，在華東地區的上海、杭州和蘇州的不同機房就是同一地區的可用區域。同一地區的可用區域之間有內網連接，流量不占用公網帶寬，因此區域是微服務集群內流量能夠觸及的最大範圍。應用程式是部署在同一區域內，還是部署到不同的可用區域中，取決於你是否有需要做異地備援，以及對網絡延遲的容忍程度。</li></ol><p>如果你追求高可用，譬如希望系統即使在某個地區發生電力或者骨幹網絡中斷時仍然可用，那可以考慮將系統部署在多個區域中。注意異地容災和異地雙活的差別：容災是非實時的同步，而雙活是實時或者準實時的，跨地域或者跨區域做容災都可以，但一般只能跨區域做雙活，當然也可以將它們結合起來同時使用，即「兩地三中心」模式。</p><p>如果你追求低延遲，譬如對時間有高要求的 SLA 應用，或者網絡遊戲服務器等，那就應該考慮將系統的所有服務都只部署在同一個區域中，因為儘管內網連接不受限於公網帶寬，但畢竟機房之間的專線容量也是有限的，難以跟機房內部的交換機相比，延時也受物理距離、網絡跳點數量等因素的影響。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/NoobTechNote/NoobTechNote.github.io/tree/main/docs/sg/fenix-architecture/ch7.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-09-10T08:26:04.000Z">Sep 10, 2023</time></b> by <b>Chestermozhao</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/sg/fenix-architecture/ch6"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Ch6: 分佈式共識算法</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/sg/fenix-architecture/ch8"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Ch8: 流量治理</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#71-服務發現service-discovery" class="table-of-contents__link toc-highlight">7.1 服務發現（Service Discovery）</a><ul><li><a href="#711-服務發現的意義" class="table-of-contents__link toc-highlight">7.1.1 服務發現的意義</a></li><li><a href="#712-可用與可靠availability-and-reliability" class="table-of-contents__link toc-highlight">7.1.2 可用與可靠（Availability and Reliability）</a></li><li><a href="#713-註冊中心實現" class="table-of-contents__link toc-highlight">7.1.3 註冊中心實現</a></li></ul></li><li><a href="#72-閘道器與路由gateways-and-routers" class="table-of-contents__link toc-highlight">7.2 閘道器與路由（Gateways and Routers）</a><ul><li><a href="#721-閘道器的職責responsibilities-of-gateways" class="table-of-contents__link toc-highlight">7.2.1 閘道器的職責（Responsibilities of Gateways）</a></li><li><a href="#722-網路-io-模型network-io-models" class="table-of-contents__link toc-highlight">7.2.2 網路 I/O 模型（Network I/O Models）</a></li><li><a href="#723-backends-for-frontends-閘道器backends-for-frontends-gateways" class="table-of-contents__link toc-highlight">7.2.3 Backends for Frontends 閘道器（Backends for Frontends Gateways）</a></li></ul></li><li><a href="#73-客戶端負載平衡client-side-load-balancing" class="table-of-contents__link toc-highlight">7.3 客戶端負載平衡（Client-side Load Balancing）</a><ul><li><a href="#731-客戶端負載平衡器client-side-load-balancers" class="table-of-contents__link toc-highlight">7.3.1 客戶端負載平衡器（Client-side Load Balancers）</a></li><li><a href="#732-代理負載均衡器proxy-load-balancers" class="table-of-contents__link toc-highlight">7.3.2 代理負載均衡器（Proxy Load Balancers）</a></li><li><a href="#733-地域與區域regions-and-zones" class="table-of-contents__link toc-highlight">7.3.3 地域與區域（Regions and Zones）</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023. DEX Study Group</div></div></div></footer></div>
<script src="/assets/js/runtime~main.d604e16f.js"></script>
<script src="/assets/js/main.f1e20d8a.js"></script>
</body>
</html>